<!DOCTYPE html>

<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-9ndCyUaIbzAi2FUVXJi0CjmCapSmO7SnpJef0486qhLnuZ2cdeRhO02iuK6FUUVM" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js" integrity="sha384-geWF76RCwLtnZ8qwWowPQNguL3RmwHVBC9FhGdlKrxdiJJigb/j/68SIy3Te4Bkz" crossorigin="anonymous"></script>
    <link rel="apple-touch-icon" sizes="152x152" href="../static/favicon/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../static/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../static/favicon/favicon-16x16.png">
    <link rel="manifest" href="../static/favicon/site.webmanifest">
    <link rel="mask-icon" href="../static/favicon/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="theme-color" content="#ffffff">
    <script type="text/javascript" src="../static/ckeditor/ckeditor-init.js"></script>
    <script type="text/javascript" src="../static/ckeditor/ckeditor/ckeditor.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>

    <!-- and it's easy to individually load additional languages -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/go.min.js"></script>

    <title>
        Какой вес у пустой структуры
    </title>
    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
            new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
        'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KFVDXM9B');</script>
    <!-- End Google Tag Manager -->

    <meta name="yandex-verification" content="fbc87e7cf8354d83" />
</head>

<body style="min-height: 100vh; display: flex; flex-direction: column; justify-content: space-between">
<!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-KFVDXM9B"
                  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->
<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
    (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
        m[i].l=1*new Date();
        for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}
        k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
    (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

    ym(95314788, "init", {
        clickmap:true,
        trackLinks:true,
        accurateTrackBounce:true
    });
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/95314788" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->
<nav class="navbar navbar-expand-lg" style="background-color: #e3f2fd;">
    <div class="container">
        <div class="fs-2 me-2 nav-link"><a class="nav-link navbar-brand fs-4" href="../index.html">☀️interviews</a></div>
        <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarSupportedContent">
            <ul class="navbar-nav me-auto mb-2 mb-lg-0">
                <li class="nav-item active">
                    <a class="nav-link" href="../index.html">Вопросы</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="../mock.html">Собесы</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="../mentor.html">Менторы</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="../analytic.html">Требования</a>
                </li>
            </ul>
            <a class="btn btn-sm btn btn-danger" href="https://t.me/+Korj4gSMfStlNDAy" target="_blank" type="button"><i class="bi bi-lock"></i> Приватная база собесов</a>
        </div>
    </div>
</nav>
<main class="container" style="flex: 1 1 auto;">


    <div class="row">
        <b>1. Как каналы устроены в Go ?</b>
        <p>
            Каналы в Go представляют собой механизм для обмена данными между горутинами. Они позволяют безопасно передавать значения между параллельными потоками выполнения. Каналы могут быть созданы с помощью функции <code>make(chan Type)</code>, где <code>Type</code> — это тип данных, который будет передаваться через канал. Каналы могут быть буферизированными и небуферизированными, что влияет на способ синхронизации между отправителем и получателем.
        </p>

        <b>2. Что такое горутины ?</b>
        <p>
            Горутины — это легковесные потоки выполнения в Go, которые позволяют выполнять функции асинхронно. Они создаются с помощью ключевого слова <code>go</code>, за которым следует вызов функции. Горутины управляются планировщиком Go, который позволяет эффективно распределять ресурсы между ними.
        </p>

        <b>3. Что такое интерфейсы ?</b>
        <p>
            Интерфейсы в Go определяют набор методов, которые должны реализовывать структуры. Они позволяют создавать гибкие и расширяемые программы, так как структуры могут реализовывать несколько интерфейсов, а функции могут принимать интерфейсы в качестве параметров, что способствует полиморфизму.
        </p>

        <b>4. В чем разница слайсов и массивов ?</b>
        <p>
            Массивы в Go имеют фиксированный размер, который задается при их создании, тогда как слайсы являются динамическими и могут изменять свой размер. Слайсы представляют собой ссылочный тип, который содержит указатель на массив, длину и емкость, что делает их более гибкими в использовании.
        </p>

        <b>5. Как работает Map ?</b>
        <p>
            Map в Go — это коллекция пар "ключ-значение". Она обеспечивает быстрый доступ к значениям по ключам и реализует хэш-таблицы. Map создаются с помощью функции <code>make(map[KeyType]ValueType)</code>, где <code>KeyType</code> и <code>ValueType</code> — это типы ключей и значений соответственно. Map не гарантирует порядок элементов.
        </p>

        <b>6. Как строки работают в Golang внутри ?</b>
        <p>
            Строки в Go представляют собой неизменяемые последовательности байтов (UTF-8). Каждая строка хранит указатель на массив байтов и его длину. Из-за неизменяемости строк, любые операции, которые изменяют строку, создают новую строку.
        </p>

        <b>7. Как устроен Map в Go ?</b>
        <p>
            Map в Go реализован как хэш-таблица, где ключи хэшируются для быстрого доступа к значениям. При создании map выделяется память для хранения пар "ключ-значение", а при добавлении элементов происходит перераспределение памяти при необходимости.
        </p>

        <b>8. Как устроены контексты в Go ?</b>
        <p>
            Контексты в Go представляют собой механизм для передачи дедлайнов, отмены и других значений через API. Контекст создается с помощью функции <code>context.Background()</code> или <code>context.TODO()</code>, и может быть передан между горутинами для управления временем выполнения и отменой операций.
        </p>

        <b>9. Как слайсы работают внутри ?</b>
        <p>
            Слайсы в Go представляют собой обертку над массивами и хранят указатель на массив, длину и емкость. При добавлении элементов с помощью функции <code>append()</code> может происходить выделение новой памяти, если текущий массив недостаточен для хранения новых элементов.
        </p>

        <b>10. Зачем нужны транзакции базе данных?</b>
        <p>
            Транзакции необходимы для обеспечения целостности данных и атомарности операций в базе данных. Они позволяют группировать несколько операций в одну логическую единицу работы, которая либо выполняется полностью, либо не выполняется вовсе, предотвращая возникновение неполных или неконсистентных данных.
        </p>

        <b>11. В чем разница процесса и потока в рамках операционной системы ?</b>
        <p>
            Процесс — это независимая программа, выполняющаяся в своей памяти, тогда как поток — это легковесная единица выполнения внутри процесса, которая использует общую память процесса. Потоки более эффективны в использовании ресурсов по сравнению с процессами.
        </p>

        <b>12. Какие типы каналов существуют ?</b>
        <p>
            В Go существуют два типа каналов:
            1. Небуферизированные каналы — передача данных происходит синхронно, отправитель блокируется до получения данных получателем.
            2. Буферизированные каналы — позволяют отправлять данные без немедленного получения, пока не будет заполнен буфер.
        </p>

        <b>13. Как работает Select в Go ?</b>
        <p>
            Оператор <code>select</code> в Go позволяет ждать нескольких операций над каналами одновременно. Он блокирует выполнение до тех пор, пока одна из операций не станет доступной, после чего выполняется соответствующий блок кода.
        </p>

        <b>14. В чем разница TCP и UDP Протоколы ?</b>
        <p>
            TCP (Transmission Control Protocol) — это надежный протокол с установлением соединения и гарантией доставки пакетов, тогда как UDP (User Datagram Protocol) — это ненадежный протокол без установления соединения, который не гарантирует доставку данных и порядок их получения.
        </p>

        <b>15. Что такое WaitGroup ?</b>
        <p>
            WaitGroup — это синхронизатор, который позволяет ожидать завершения группы горутин. Он используется для отслеживания количества активных горутин и блокирует выполнение до тех пор, пока все горутины не завершатся.
        </p>

        <b>16. Как ООП в Go реализовано ?</b>
        <p>
            В Go нет классического ООП как в других языках; вместо этого используется композиция и интерфейсы для достижения полиморфизма. Структуры могут иметь методы, а интерфейсы определяют набор методов для реализации.
        </p>

        <b>17. Зачем нужна конструкция defer ?</b>
        <p>
            Конструкция <code>defer</code> используется для отложенного выполнения функции до выхода из текущей функции. Это удобно для освобождения ресурсов, закрытия файлов или выполнения других завершающих операций.
        </p>

        <b>18. В чем разница между буферизированными и небуферизированными каналами ?</b>
        <p>
            Небуферизированные каналы требуют синхронизации между отправителем и получателем: отправитель блокируется до получения данных получателем. Буферизированные каналы позволяют отправлять данные без немедленного получения до тех пор, пока буфер не будет заполнен.
        </p>

        <b>19. Что такое mutex, какие они бывают и как их использовать ?</b>
        <p>
            Mutex (взаимное исключение) — это механизм синхронизации для защиты разделяемых ресурсов от одновременного доступа несколькими горутинами. В Go есть два типа mutex'ов: <code>sync.Mutex</code> и <code>sync.RWMutex</code>, последний позволяет нескольким читателям одновременно получать доступ к ресурсу при отсутствии писателей.
        </p>

        <b>20. Какие недостатки есть у Go ?</b>
        <p>
            Недостатки Go включают ограниченные возможности поддержки обобщений (generics), отсутствие встроенной поддержки исключений, а также сложность работы с ошибками и управление зависимостями.
        </p>

        <b>21. Какие индексы знаешь ?</b>
        <p>
            Индексы могут быть различных типов:
            1. Простые индексы (на основе одного поля).
            2. Составные индексы (на основе нескольких полей).
            3. Уникальные индексы (гарантируют уникальность значений).
            4. Полнотекстовые индексы (для поиска по текстовым полям).
        </p>

        <b>22. Что такое context в Go ?</b>
        <p>
            Context в Go — это структура, которая передает информацию о времени выполнения (дедлайны) и отмене между горутинами. Он используется для управления длительными операциями и передачи значений между функциями.
        </p>

        <b>23. Какие БД бывают ?</b>
        <p>
            Базы данных можно классифицировать на:
            1. Реляционные (например, MySQL, PostgreSQL).
            2. Нереляционные (например, MongoDB, Redis).
            3. Графовые (например, Neo4j).
            4. Документоориентированные (например, CouchDB).
        </p>

        <b>24. В чем ключевое различие слайса от массива ?</b>
        <p>
            Ключевое различие заключается в том, что массивы имеют фиксированный размер, тогда как слайсы динамически изменяют свой размер и представляют собой ссылочный тип на массив.
        </p>

        <b>25. Что будет, если попытатся писать в закрытом канале ?</b>
        <p>
            Если попытаться записать данные в закрытый канал, произойдет паника (panic) во время выполнения программы.
        </p>

        <b>26. Что такое репликация Базы данных ?</b>
        <p>
            Репликация базы данных — это процесс копирования и поддержания объектов базы данных между несколькими серверами для повышения доступности и надежности данных.
        </p>

        <b>27. В чем отличия http 1.1 и http 2 Протоколов ?</b>
        <p>

            HTTP/2 предлагает более эффективное использование сетевых ресурсов благодаря мультиплексированию потоков, сжатия заголовков и улучшенной производительности по сравнению с HTTP/1.1, который использует последовательные запросы и менее эффективен при работе с большим количеством ресурсов.
        </p>

        <b>28. Какие бывают типы в Go ?</b>
        <p>
            В Go существуют следующие типы:
            1. Примитивные типы (int, float64, bool, string).
            2. Сложные типы (массивы, срезы).
            3. Структуры.
            4. Интерфейсы.
            5. Maps.
            6. Каналы.
        </p>

        <b>29. Что такое гарбэдж коллектор ?</b>
        <p>
            Гарбэдж коллектор — это автоматическая система управления памятью, которая освобождает неиспользуемую память путем удаления объектов, на которые больше нет ссылок.
        </p>

        <b>30. Как устроены строки в Go ?</b>
        <p>
            Строки в Go представляют собой неизменяемые последовательности байтов UTF-8 и хранятся как указатели на массив байтов вместе с длиной строки.
        </p>

        <b>31. Как устроены таблицы Map Алгоритмы, структуры?</b>
        <p>
            Таблицы Map реализованы как хэш-таблицы с использованием хэш-функций для быстрого доступа к значениям по ключам. При добавлении нового элемента происходит вычисление хэша ключа для определения позиции в таблице.
        </p>

        <b>32. Что такое SOLID ?</b>
        <p>
            SOLID — это набор принципов объектно-ориентированного проектирования:
            1. S - Single Responsibility Principle (Принцип единственной ответственности).
            2. O - Open/Closed Principle (Принцип открытости/закрытости).
            3. L - Liskov Substitution Principle (Принцип подстановки Лисков).
            4. I - Interface Segregation Principle (Принцип разделения интерфейсов).
            5. D - Dependency Inversion Principle (Принцип инверсии зависимостей).
        </p>

        <b>33. Разница между WHERE и HAVING ?</b>
        <p>
            <code>WHERE</code> используется для фильтрации строк перед группировкой данных (в операторе <code>SELECT</code>), тогда как <code>HAVING</code> используется для фильтрации групп после применения агрегатных функций.
        </p>

        <b>34. Насколько увеличивается слайс при append ?</b>
        <p>
            При использовании функции <code>append()</code>, если емкость слайса недостаточна для добавления новых элементов, то емкость обычно удваивается (или увеличивается на фиксированное значение), чтобы обеспечить место для новых элементов.
        </p>

        <b>35. Какие основные структуры данных есть в Go ?</b>
        <p>
            Основные структуры данных в Go включают:
            1. Массивы
            2. Срезы
            3. Maps
            4. Структуры
            5. Каналы
        </p>

        <b>36. В чем разница между императивным и декларативным программированием ?</b>
        <p>
            Императивное программирование описывает шаги для достижения результата (как), тогда как декларативное программирование описывает желаемый результат без указания конкретных шагов (что).
        </p>

        <b>37. Чем горутины отличаются от тредов ?</b>
        <p>
            Горутины более легковесны по сравнению с потоками (тредами), так как они управляются планировщиком Go и требуют меньше ресурсов на создание и переключение контекста.
        </p>

        <b>38. Возможны ли случаи, когда перебор по слайсу будет быстрее чем по map ?</b>
        <p>
            Да, перебор по слайсу может быть быстрее при небольшом количестве элементов из-за отсутствия накладных расходов на хэширование ключей в map.
        </p>

        <b>39. Кто такое шардинг Базы данных?</b>
        <p>
            Шардинг базы данных — это метод распределения данных по нескольким серверам или базам данных для повышения производительности и масштабируемости системы путем разделения больших наборов данных на более мелкие части (шарды).
        </p>

        <b>40. Кто такое утиная типизация (Интерфейсы) ?</b>
        <p>
            Утиная типизация — это концепция полиморфизма, согласно которой объект считается подходящим для использования в определенном контексте, если он реализует необходимые методы, независимо от его фактического типа.
        </p>

        <b>41. Какие преимущества есть у Go ?</b>
        <p>
            Преимущества Go включают:
            1. Простота синтаксиса
            2. Высокая производительность
            3. Поддержка параллелизма
            4. Статическая типизация
            5. Удобные инструменты для разработки
        </p>

        <b>42. Каково стандартное поведение в Go при передаче функции ?</b>
        <p>
            При передаче функции в Go передается значение функции (копия), а не ссылка на нее; однако функции могут замыкаться над переменными из внешней области видимости.
        </p>

        <b>43. Как инкапсуляция осуществлена в Golang ?</b>
        <p>
            Инкапсуляция в Go достигается за счет использования экспортируемых (с заглавной буквы) и неэкспортируемых (с маленькой буквы) именованных объектов; только экспортируемые объекты доступны за пределами пакета.
        </p>

        <b>44. Что делает команда kill в linux ?</b>
        <p>
            Команда <code>kill</code> в Linux отправляет сигнал процессу для его завершения или выполнения других действий; по умолчанию она отправляет сигнал SIGTERM для корректного завершения процесса.
        </p>

        <b>45. Как завершить много горутин ?</b>
        <p>
            Для завершения нескольких горутин можно использовать контекст с отменой или WaitGroup для ожидания завершения всех горутин перед выходом из программы.
        </p>

        <b>46. Как наследование осуществлено в Golang ?</b>
        <p>
            В Go нет явного наследования классов; вместо этого используется композиция: одна структура может содержать другую структуру как поле, что позволяет использовать методы вложенной структуры.
        </p>

        <b>47. Что такое HTTP Протоколы ?</b>
        <p>
            HTTP (HyperText Transfer Protocol) — это протокол прикладного уровня для передачи гипертекстовой информации по сети; он определяет правила обмена данными между клиентом и сервером.
        </p>

        <b>48. Что такое эвакуация в Golang, и в каком случае она будет происходить?</b>
        <p>
            Эвакуация (evacuation) происходит во время работы гарбэдж коллекторов для перемещения объектов памяти из одного места в другое с целью оптимизации использования памяти; она может происходить при необходимости освобождения фрагментированной памяти или при перераспределении объектов.
        </p>

        <b>49. Что такое микросервисная архитектура ? </b>
        <p>
            Микросервисная архитектура — это стиль проектирования программного обеспечения, при котором приложение состоит из набора небольших сервисов, каждый из которых выполняет отдельную бизнес-функцию и взаимодействует с другими сервисами через API.
        </p>

        <b>50. Чем отличия HTTP и HTTPS ? </b>
        <p>
            Основное отличие заключается в том, что HTTPS (HTTP Secure) использует шифрование SSL/TLS для защиты данных при передаче между клиентом и сервером, обеспечивая конфиденциальность и целостность данных.
        </p>
        <b>51. Как полиморфизм осуществлен в Golang</b>
        <p>
            Полиморфизм в Go достигается через интерфейсы. Любая структура, реализующая методы интерфейса, может быть использована как экземпляр этого интерфейса, что позволяет создавать функции, работающие с различными типами, не зная их конкретных реализаций.
        </p>

        <b>52. Расскажи, какой паттерн использовал в продукте/своем коде</b>
        <p>
            В своем коде я использовал паттерн "Фабрика", который позволяет создавать объекты без указания конкретного класса. Это упрощает добавление новых типов объектов и улучшает читаемость кода.
        </p>

        <b>53. Расскажи про паттерн Singleton(Одиночка)</b>
        <p>
            Паттерн Singleton гарантирует, что у класса есть только один экземпляр и предоставляет глобальную точку доступа к этому экземпляру. В Go его можно реализовать с помощью синхронизации для предотвращения создания нескольких экземпляров.
        </p>

        <b>54. Кто управляет горутинами</b>
        <p>
            Горутинами управляет планировщик Go (runtime scheduler), который распределяет их выполнение по доступным потокам операционной системы, обеспечивая эффективное использование ресурсов.
        </p>

        <b>55. Как преобразовать строку в int и наоборот</b>
        <p>
            Для преобразования строки в int можно использовать функцию <code>strconv.Atoi()</code>, а для преобразования int в строку — <code>strconv.Itoa()</code>.
        </p>

        <b>56. Что такое обычный int и какие есть нюансы его реализации</b>
        <p>
            Обычный int в Go — это целочисленный тип данных, размер которого зависит от архитектуры (32 или 64 бита). Это может привести к различиям в производительности и диапазоне значений на разных платформах.
        </p>

        <b>57. Можно ли сделать int(string) и string(int) соответственно</b>
        <p>
            Непосредственно преобразование <code>int(string)</code> невозможно; вместо этого нужно использовать функции из пакета <code>strconv</code>. Для <code>string(int)</code> используется функция <code>strconv.Itoa()</code>.
        </p>

        <b>58. Сколько в памяти занимают реализации int32 и int64</b>
        <p>
            <code>int32</code> занимает 4 байта, а <code>int64</code> — 8 байт в памяти.
        </p>

        <b>59. Какие предельные значения int32 и int64</b>
        <p>
            Предельные значения:
            - <code>int32</code>: от -2,147,483,648 до 2,147,483,647.
            - <code>int64</code>: от -9,223,372,036,854,775,808 до 9,223,372,036,854,775,807.
        </p>

        <b>60. Какой результат получим если разделить int на 0 и float на 0</b>
        <p>
            Деление целого числа (int) на 0 приведет к панике во время выполнения программы, тогда как деление числа с плавающей запятой (float) на 0 вернет бесконечность (Inf) или NaN (Not a Number) в зависимости от контекста.
        </p>

        <b>61. Расскажи про паттерн Factory(Фабрика)</b>
        <p>
            Паттерн "Фабрика" позволяет создавать объекты без указания конкретного класса. Он инкапсулирует создание объектов и может возвращать разные подклассы в зависимости от условий.
        </p>

        <b>62. Отличие uint от int</b>
        <p>
            <code>uint</code> — это беззнаковый целочисленный тип, который не может хранить отрицательные значения. <code>int</code> может быть как положительным, так и отрицательным. Размеры могут быть одинаковыми, но диапазоны значений различаются.
        </p>

        <b>63. Расскажи про паттерн Builder(Строитель)</b>
        <p>
            Паттерн "Строитель" используется для поэтапного создания сложных объектов. Он отделяет конструкцию объекта от его представления, позволяя создавать разные представления одного и того же типа объекта.
        </p>

        <b>64. Что такое runtime (планировщик scheduler)</b>
        <p>
            Runtime в Go — это среда выполнения, которая управляет выполнением программ. Планировщик (scheduler) распределяет горутины по потокам операционной системы для оптимального использования ресурсов.
        </p>

        <b>65. Как устроен runtime в Go</b>
        <p>
            Runtime Go включает в себя планировщик горутин, сборщик мусора и управление памятью. Он отвечает за создание и завершение горутин, а также за управление их состоянием и взаимодействием с системой.
        </p>

        <b>66. Как эффективно склеивать строки (конкатенация строк)</b>
        <p>
            Для эффективной конкатенации строк в Go рекомендуется использовать <code>strings.Builder</code>, который оптимизирует выделение памяти и уменьшает количество временных строк.
        </p>

        <b>67. Какие есть нюансы при итерации по строке</b>
        <p>
            При итерации по строке в Go нужно учитывать, что строки являются последовательностями байтов UTF-8. Это значит, что один символ может занимать более одного байта; для корректной работы следует использовать <code>for range</code>.
        </p>

        <b>68. С какими паттернами проектирования знакомы</b>
        <p>
            Я знаком с различными паттернами проектирования, такими как Singleton, Factory, Builder, Observer, Strategy и Decorator.
        </p>

        <b>69. Как определить количество символов для строки</b>
        <p>
            Количество символов в строке можно определить с помощью функции <code>len(s)</code>, но она возвращает количество байтов. Для получения количества символов (rune) следует использовать цикл <code>for range</code>.
        </p>

        <b>70. Что будет если сложить строки</b>
        <p>
            Если сложить строки в Go с помощью оператора <code>+</code>, получится новая строка, содержащая объединенные значения обеих строк.
        </p>

        <b>71. Сколько очередей в паттерне</b>
        <p>
            В паттерне проектирования обычно используется одна очередь для управления задачами или событиями, но конкретное количество может варьироваться в зависимости от реализации.
        </p>

        <b>72. Расскажи про планирование goroutine</b>
        <p>
            Планирование goroutine осуществляется планировщиком Go, который распределяет выполнение горутин по потокам операционной системы. Он использует алгоритмы для обеспечения эффективного выполнения и минимизации блокировок.
        </p>

        <b>73. Как можно оперировать строками</b>
        <p>
            Строками в Go можно оперировать с помощью встроенных функций из пакета <code>strings</code>, таких как <code>strings.Contains()</code>, <code>strings.Split()</code>, <code>strings.Join()</code>, а также конкатенацией и форматированием.
        </p>

        <b>74. Что происходит при склеивании строк</b>
        <p>
            При склеивании строк создается новая строка с объединенными значениями обеих строк; это может привести к созданию временных объектов в памяти.
        </p>

        <b>75. Расскажи о GMP паттерне</b>
        <p>
            GMP — это модель параллелизма в Go, которая состоит из Goroutines (горутин), которые выполняются параллельно; M (потоки) — это нативные потоки операционной системы; P (планировщики) — это логические процессоры для управления выполнением горутин.
        </p>

        <b>76. Можно ли изменить определенный символ в строке</b>
        <p>
            Строки в Go неизменяемы, поэтому нельзя изменить отдельный символ непосредственно; вместо этого нужно создать новую строку с необходимыми изменениями.
        </p>

        <b>77. Какие функции у map</b>
        <p>
            У map есть функции для добавления (<code>[key] = value</code>), удаления (<code>delete(map, key)</code>) и проверки наличия ключа (<code>, ok := map[key]</code>) значений.
        </p>

        <b>78. Что из себя представляет тип данных string в языке Golang</b>
        <p>
            Тип данных string в Go представляет собой неизменяемую последовательность байтов UTF-8 и хранит указатель на массив байтов вместе с длиной строки.
        </p>

        <b>79. Сколько весит число в байтах</b>
        <p>
            Размер числа зависит от его типа:
            - <code>int32</code>: 4 байта
            - <code>int64</code>: 8 байт
            - <code>int</code>: зависит от архитектуры (4 или 8 байт).
        </p>

        <b>80. Как работает сборщик мусора в Go</b>
        <p>
            Сборщик мусора в Go автоматически управляет памятью, освобождая неиспользуемые объекты и предотвращая утечки памяти; он использует алгоритмы для определения объектов без ссылок и освобождения занимаемой ими памяти.
        </p>

        <b>81. Какой концепт конструкция defer помогает реализовывать</b>
        <p>
            Конструкция <code>defer</code> помогает реализовывать концепт отложенного выполнения функций до выхода из текущей функции, что удобно для освобождения ресурсов и выполнения завершающих операций.
        </p>

        <b>82. Какой вес у пустой структуры</b>
        <p>
            Пустая структура в Go занимает 0 байт памяти; она используется для создания уникальных типов без хранения данных.
        </p>

        <b>83. Как со слайсами работать</b>
        <p>
            Со слайсами можно работать с помощью встроенных функций для добавления (<code>append()</code>), изменения элементов по индексу (<code>s[i]</code>) и итерации с помощью циклов (<code>for range</code>).
        </p>

        <b>84. Сколько весит пустая строка в байтах</b>
        <p>
            Пустая строка занимает 0 байт данных плюс 16 байт (или 24 байта на 64-битных системах) для хранения метаданных о строке (указатель на массив и длина).
        </p>

        <b>85. Что будет в Map, если не делать make или short assign</b>
        <p>
            Если не использовать <code>make()</code> или короткое присваивание при объявлении map, попытка доступа к ней приведет к панике во время выполнения программы.
        </p>

        <b>86. Какое свойство должно быть у ключа в Map</b>
        <p>
            Ключи в map должны быть сравнимыми; это означает, что они должны быть одного из следующих типов: простые типы (числа, строки), структуры и массивы (если все их элементы тоже сравнимы).
        </p>

        <b>87. У ресивера имеется звёздочка - что это значит</b>
        <p>
            Звездочка у ресивера означает, что метод принимает указатель на структуру вместо самой структуры; это позволяет изменять поля структуры внутри метода.
        </p>

        <b>88. Как работает append в слайсе</b>
        <p>
            Функция <code>append()</code> добавляет элементы к срезу; если емкость среза недостаточна, создается новый массив с увеличенной емкостью, и элементы копируются туда.
        </p>

        <b>89. Что будет, если подставить переменную в массив</b>
        <p>
            Если подставить переменную в массив при объявлении или присваивании значений, будет ошибка компиляции, если размер массива не совпадает с размером переменной или если переменная не является допустимым типом.
        </p>

        <b>90. Как думаешь, будут ли MAP ordered?</b>
        <p>
            Нет, map в Go не гарантирует порядок элементов; порядок может изменяться при добавлении или удалении элементов.
        </p>

        <b>91. Как правильно объявлять Маппу</b>
        <p>
            Правильное объявление map выглядит так: <code>myMap := make(map[KeyType]ValueType)</code>, где <code>KeyType</code> — тип ключей, а <code>ValueType</code> — тип значений.
        </p>

        <b>92. Как быстро можно что-то найти, если искать по индексу в слайсе и в Маппе?</b>
        <p>
            Поиск по индексу в срезе требует линейного времени O(n), тогда как поиск по ключу в map осуществляется за константное время O(1) благодаря хэшированию ключей.
        </p>

        <b>93. Какие отличия у быстрого объявления и объявления через var?</b>
        <p>
            Быстрое объявление (<code>x := value</code>) автоматически выводит тип переменной на основе присвоенного значения, тогда как объявление через <code>var x Type = value</code> требует явного указания типа переменной.
        </p>

        <b>94. Какая средняя сложность поиска по слайсу и по map?</b>
        <p>
            Средняя сложность поиска по слайсу составляет O(n), а по map — O(1) благодаря хэшированию ключей.
        </p>

        <b>95. Как объявлять слайс?</b>
        <p>
            Слайс можно объявить следующим образом:
            - <code>s := []Type{}</code>,
            - <code>s := make([]Type, length)</code>,
            - или просто присвоением значений: <code>s := []int{1, 2, 3}</code>.
        </p>

        <b>96. Какие ключи могут быть в МАПе?</b>
        <p>
            В качестве ключей в map могут использоваться только те типы данных, которые поддерживают сравнение: простые типы (числа, строки), структуры и массивы (если все их элементы тоже сравнимы).
        </p>

        <b>97. Какие типы данных можно использовать в ключах?</b>
        <p>
            В качестве ключей можно использовать следующие типы:
            - Примитивные типы (int, string)
            - Структуры
            - Массивы
            Однако ключи не могут быть функциями или срезами.
        </p>

        <b>98. Как устроены горутины, сколько памяти они занимают в стеке?</b>
        <p>
            Горутины представляют собой легковесные потоки выполнения; они занимают минимальное количество памяти на стеке (обычно около 2 КБ на старте), что позволяет создавать тысячи горутин одновременно без значительного расхода ресурсов.
        </p>

        <b>99. Что такое функция copy?</b>
        <p>
            Функция <code>copy(dst []T, src []T)</code> копирует элементы из среза <code>src</code> в срез <code>dst</code>. Она возвращает количество скопированных элементов и останавливается при достижении конца одного из срезов.
        </p>
        <b>100. Как можно слить два слайса?</b>
        <p>
            Два слайса можно слить с помощью функции <code>append(slice1, slice2...)</code>, где <code>slices2...</code> распаковывает второй срез для добавления его элементов к первому.
        </p>
        <b>101. Как можно нарезать слайс? Какие есть нюансы, подводные камни</b>
        <p>
            Слайс можно нарезать с помощью синтаксиса <code>slice[start:end]</code>. Нюансы включают в себя то, что нарезка создает новый срез, который ссылается на тот же массив, что и оригинальный срез, поэтому изменения в одном срезе могут повлиять на другой.
        </p>

        <b>102. Почему нельзя брать ссылку на значение, хранящееся по ключу в map?</b>
        <p>
            Нельзя брать ссылку на значение в map, потому что при изменении значения по ссылке может возникнуть ситуация, когда ключ больше не будет указывать на правильное значение, особенно если ключи изменяются или используются в других операциях.
        </p>

        <b>103. Какие есть особенности синтаксиса получения и записи значений в map?</b>
        <p>
            Для получения значения из map используется синтаксис <code>value, ok := myMap[key]</code>, где <code>ok</code> указывает, найден ли ключ. Для записи используется <code>myMap[key] = value</code>. Если ключ не существует, он будет создан автоматически.
        </p>

        <b>104. Как происходит поиск по ключу в map?</b>
        <p>
            Поиск по ключу в map осуществляется за константное время O(1) благодаря хэшированию ключей. Go использует хэш-таблицы для эффективного доступа к значениям по ключам.
        </p>

        <b>105. Каков порядок перебора map?</b>
        <p>
            Порядок перебора элементов в map не определен и может изменяться при каждой итерации. Это связано с тем, что Go использует хэш-таблицы, и порядок зависит от хэш-функции и распределения ключей.
        </p>

        <b>106. Что такое len и capacity в slice Go?</b>
        <p>
            <code>len</code> возвращает текущее количество элементов в срезе, а <code>capacity</code> показывает максимальное количество элементов, которое может храниться в выделенной памяти без перераспределения.
        </p>

        <b>107. Что такое хэш-таблица?</b>
        <p>
            Хэш-таблица — это структура данных, которая использует хэш-функцию для преобразования ключей в индексы массива, позволяя осуществлять быстрый доступ к значениям по ключам.
        </p>

        <b>108. Что такое массив (array)?</b>
        <p>
            Массив — это фиксированная структура данных, содержащая элементы одного типа. Его размер задается при объявлении и не может быть изменен после этого.
        </p>

        <b>109. Что такое хеш-функция?</b>
        <p>
            Хеш-функция — это функция, которая принимает входные данные (ключ) и возвращает фиксированное значение (хеш), которое используется для быстрого поиска и доступа к данным в хэш-таблицах.
        </p>

        <b>110. Что такое РПС?</b>
        <p>
            РПС (Requests Per Second) — это метрика производительности, которая измеряет количество запросов, обрабатываемых системой за одну секунду.
        </p>

        <b>111. Чем отличается микросервис от монолита?</b>
        <p>
            Микросервис — это архитектурный стиль, при котором приложение состоит из множества независимых сервисов, взаимодействующих друг с другом. Монолит же представляет собой одно целое приложение, где все компоненты tightly coupled.
        </p>

        <b>112. Опишите плюсы и минусы микросервисной архитектуры.</b>
        <p>
            Плюсы: масштабируемость, независимость развертывания, гибкость технологий. Минусы: сложность управления, необходимость межсервисного взаимодействия и возможные проблемы с сетью.
        </p>

        <b>113. Опишите плюсы и минусы монолита.</b>
        <p>
            Плюсы: простота разработки и развертывания, меньшая сложность управления. Минусы: трудности с масштабируемостью и обновлениями, высокая связность компонентов.
        </p>

        <b>114. Какие бывают версии HTTP?</b>
        <p>
            Основные версии HTTP: HTTP/1.0, HTTP/1.1 и HTTP/2. Каждая версия улучшает производительность и функциональность по сравнению с предыдущей.
        </p>

        <b>115. Что можешь сказать о HTTP3?</b>
        <p>
            HTTP/3 основан на QUIC — протоколе транспортного уровня, который обеспечивает более быструю передачу данных и улучшенное управление соединениями по сравнению с HTTP/2.
        </p>

        <b>116. Как произвести дебаг protobuff?</b>
        <p>
            Для дебага Protocol Buffers можно использовать утилиты для сериализации и десериализации данных, такие как <code>protoc</code> с флагом <code>--decode</code>, а также инструменты для визуализации данных в формате protobuf.
        </p>

        <b>117. Что такое NAT?</b>
        <p>
            NAT (Network Address Translation) — это метод преобразования адресов IP в пакетах данных, который позволяет нескольким устройствам использовать один внешний IP-адрес для доступа к интернету.
        </p>

        <b>118. Что такое HTTPS?</b>
        <p>
            HTTPS (Hypertext Transfer Protocol Secure) — это расширение протокола HTTP, которое обеспечивает безопасную передачу данных через шифрование с использованием SSL/TLS.
        </p>

        <b>119. Что такое SSL?</b>
        <p>
            SSL (Secure Sockets Layer) — это протокол безопасности, который обеспечивает шифрование данных между клиентом и сервером для защиты конфиденциальной информации.
        </p>

        <b>120. Что такое TLS?</b>
        <p>
            TLS (Transport Layer Security) — это современная версия протокола SSL, обеспечивающая более высокий уровень безопасности для передачи данных по сети.
        </p>

        <b>121. Есть ли отличия между SSL и TLS?</b>
        <p>
            Да, TLS является усовершенствованной версией SSL с улучшенными механизмами шифрования и аутентификации; использование TLS рекомендуется вместо устаревших версий SSL.
        </p>

        <b>122. Как проверить тип переменной в среде выполнения?</b>
        <p>
            Для проверки типа переменной в Go можно использовать оператор <code>switch</code> с типами или функцию <code>reflect.TypeOf(variable)</code>.
        </p>

        <b>123. Как тестировать распределённую систему?</b>
        <p>
            Тестирование распределенных систем включает в себя интеграционное тестирование компонентов, нагрузочное тестирование, тестирование отказоустойчивости и мониторинг производительности.
        </p>

        <b>124. Знакомы ли с lock-free концепцией?</b>
        <p>
            Да, lock-free концепция подразумевает использование алгоритмов, которые позволяют нескольким потокам безопасно взаимодействовать без блокировок, минимизируя время ожидания.
        </p>

        <b>125. Можешь описать принцип работы lock-free?</b>
        <p>
            Lock-free алгоритмы используют атомарные операции и механизмы для управления состоянием данных, позволяя потокам продолжать выполнение без блокировок даже при конкуренции за ресурсы.
        </p>

        <b>126. Как можно измерить использование памяти в Go? Что такое pprof?</b>
        <p>
            Использование памяти в Go можно измерить с помощью пакета <code>pprof</code>, который предоставляет инструменты для профилирования приложений и анализа использования памяти и производительности.
        </p>

        <b>127. Способы поиска проблем производительности на проде.</b>
        <p>
            Способы поиска проблем производительности включают использование профайлеров (например, pprof), мониторинг метрик (например, latency, throughput), логирование и анализ поведения системы под нагрузкой.
        </p>

        <b>128. Как встроить стандартный профайлер в свое приложение?</b>
        <p>
            Стандартный профайлер можно встроить в приложение через пакет <code>net/http/pprof</code>, добавив обработчики для профилирования CPU, памяти и блокировок на определенных маршрутах.
        </p>

        <b>129. Overhead от стандартного профайлера.</b>
        <p>
            Стандартный профайлер может добавлять некоторый overhead из-за сбора данных о производительности и использовании памяти; это может влиять на общую производительность приложения во время профилирования.
        </p>

        <b>130. Насколько безопасно передавать слайсы в разные горутины?</b>
        <p>
            Передача слайсов в разные горутины может быть небезопасной из-за возможности конкурентного доступа к данным; рекомендуется использовать каналы или мьютексы для синхронизации доступа к данным.
        </p>

        <b>131. Где потокобезопасность? Маппы безопасна?</b>
        <p>
            Map не является потокобезопасным; конкурентный доступ к map может привести к панике. Для безопасного доступа нужно использовать мьютексы или другие механизмы синхронизации.
        </p>

        <b>132. Почему Маппу не сделали более сейфовой?</b>
        <p>
            Map была разработана для высокой производительности и гибкости; добавление автоматической потокобезопасности могло бы снизить производительность и усложнить реализацию.
        </p>

        <b>133. Что можно и что нельзя делать с потокобезопасностью каналов?</b>
        <p>
            Каналы безопасны для передачи данных между горутинами; нельзя использовать их для передачи значений одновременно из нескольких горутин без синхронизации; следует избегать закрытия канала из нескольких горутин одновременно.
        </p>

        <b>134. Насколько безопасен слайс в контексте Concurrency?</b>
        <p>
            Слайсы не являются потокобезопасными; их использование в нескольких горутинах требует синхронизации через мьютексы или каналы для предотвращения гонок данных.
        </p>

        <b>135. Безопасен ли map?</b>
        <p>
            Нет, map не является потокобезопасным; конкурентные операции чтения и записи могут привести к панике или некорректному поведению программы.
        </p>

        <b>136. Насколько безопасны каналы?</b>
        <p>
            Каналы являются потокобезопасными структурами данных для передачи значений между горутинами; они обеспечивают синхронизированный доступ к данным при правильном использовании.
        </p>

        <b>137. Что следует помнить при работе с мьютексами в Go?</b>
        <p>
            При работе с мьютексами следует помнить о возможности дедлоков, необходимости разблокировки мьютексов после их захвата и о том, что мьютексы не защищают сами данные — только доступ к ним.
        </p>

        <b>138. Расскажи про аналог default в select.</b>
        <p>
            Аналог <code>default</code> в <code>select</code> позволяет выполнять код, если ни один из каналов не готов к операции; это обеспечивает возможность обработки случаев без блокировки выполнения программы.
        </p>

        <b>139. Зачем WaitGroup нужны?</b>
        <p>
            WaitGroup используется для ожидания завершения группы горутин; он позволяет отслеживать количество активных горутин и блокирует выполнение до тех пор, пока все горутины не завершатся.
        </p>

        <b>140. Что знаешь о sync.map?</b>
        <p>
            <code>sync.Map</code> — это потокобезопасная реализация карты в Go, которая позволяет безопасно читать и записывать данные из нескольких горутин без необходимости использования мьютексов.
        </p>

        <b>141. Как объединить по смыслу Маппу и Мьютексы?</b>
        <p>
            Объединить map и мьютексы можно путем создания структуры данных, содержащей мапу и мьютекс для синхронизации доступа к ней; это обеспечит безопасность при конкурентном доступе к данным.
        </p>

        <b>142. Чем отличается RW Мьютекс от обычного?</b>
        <p>
            RWMutex позволяет многим горутинам одновременно читать данные (если нет писателей), тогда как обычный мьютекс блокирует доступ ко всем операциям (чтение/запись) до завершения текущей операции.
        </p>

        <b>143. Расскажи, что такое starvation/голодание.</b>
        <p>
            Starvation (голодание) — это состояние, при котором одна или несколько горутин не могут получить доступ к ресурсам из-за того, что другие горутины постоянно занимают эти ресурсы.
        </p>

        <b>144. Какие используешь мьютексы для того, чтобы обезопасить МАПу?</b>
        <p>
            Для защиты map обычно используется <code>synchronization.Mutex</code>, чтобы обеспечить эксклюзивный доступ к карте во время операций чтения и записи.
        </p>

        <b>145. Что выполняет default в select?</b>
        <p>
            <code>default</code> в <code>select</code> выполняется немедленно, если ни один из каналов не готов к операции; это позволяет избежать блокировки выполнения программы и выполнять альтернативный код.
        </p>

        <b>146. Что будет происходить при конкуррентной записи в map? Как можно решить эту проблему?</b>
        <p>
            При конкурентной записи в map может произойти паника или некорректное поведение программы. Решением является использование мьютексов или синхронизация через каналы для обеспечения безопасного доступа к map.
        </p>

        <b>147. Как защититься от ошибки во время конкурентной записи в map?</b>
        <p>
            Для защиты от ошибок при конкурентной записи в map нужно использовать мьютексы или <code>sync.Map</code>, чтобы гарантировать эксклюзивный доступ к карте во время операций записи.
        </p>

        <b>148. Какие бывают способы синхронизации данных в Go?</b>
        <p>
            Способы синхронизации данных в Go включают использование мьютексов (<code>synchronization.Mutex</code>, <code>synchronization.RWMutex</code>), каналов и атомарных операций (<code"sync/atomic</code>) для безопасного доступа к общим данным.
        </p>
        <b>149. Что такое atomics? Какие бывают и как и когда их лучше использовать?</b>
        <p>
            Atomics — это пакет <code>sync/atomic</code>, который предоставляет атомарные операции над примитивными типами (например, int32) для безопасного изменения значений без блокировок; их лучше использовать для высокопроизводительных приложений с минимальной задержкой.
        </p>

        <b>150. Что такое lock-free структуры данных? Есть ли в Go такие?</b>
        <p>
            Lock-free структуры данных позволяют нескольким потокам безопасно взаимодействовать без использования блокировок; они обеспечивают гарантии прогресса даже при конкуренции за ресурсы. В Go нет встроенных lock-free структур данных, но их можно реализовать с использованием атомарных операций из пакета <code"sync/atomic</code>.
        </p>
        <b>151. Как можно обработать панику с помощью defer и recovery</b>
        <p>
            Panic можно обработать с помощью функции <code>recover</code>, которая вызывается в отложенной функции (<code>defer</code>). Внутри отложенной функции можно вызвать <code>recover</code>, чтобы восстановить выполнение программы и предотвратить её завершение.
        </p>

        <b>152. Можно ли использовать один и тот же буфер []byte в нескольких горутинах</b>
        <p>
            Да, можно использовать один и тот же буфер <code>[]byte</code> в нескольких горутинах, но нужно обеспечить синхронизацию доступа к этому буферу, чтобы избежать гонок данных и некорректного поведения.
        </p>

        <b>153. Какие типы мьютексов предоставляет stdlib</b>
        <p>
            Стандартная библиотека Go предоставляет два типа мьютексов: <code>sync.Mutex</code> для обычной блокировки и <code>sync.RWMutex</code> для блокировки с возможностью одновременного чтения.
        </p>

        <b>154. Как тесты и TDD влияют на организацию кода</b>
        <p>
            Тесты и методология TDD (разработка через тестирование) способствуют более четкой организации кода, улучшая его структуру, модульность и читаемость, а также помогая выявлять ошибки на ранних этапах разработки.
        </p>

        <b>155. В чём разница между сцеплением и связанностью</b>
        <p>
            Сцепление (cohesion) относится к тому, насколько связаны элементы внутри одного модуля, тогда как связанность (coupling) описывает степень зависимости между различными модулями. Высокое сцепление и низкая связанность являются признаками хорошей архитектуры.
        </p>

        <b>156. Почему в TDD тесты пишутся прежде кода</b>
        <p>
            В TDD тесты пишутся прежде кода, чтобы определить требования и ожидания к функционалу на ранней стадии разработки, что помогает избежать ошибок и улучшить дизайн системы.
        </p>

        <b>157. Если у кода плохая организация, как это поймёшь</b>
        <p>
            Плохая организация кода может проявляться в сложной структуре, трудности в понимании, наличии дублирующегося кода, высокой связанности между компонентами и отсутствии четкой документации.
        </p>

        <b>158. Каки знаешь способы общения между процессами</b>
        <p>
            Способы общения между процессами включают использование межпроцессного взаимодействия (IPC), таких как каналы, сокеты, очереди сообщений и общая память.
        </p>

        <b>159. Чем воспользоваться, если два процесса запрашивают доступ к оперативной памяти, а свободного места только для одного</b>
        <p>
            В таком случае можно использовать механизмы синхронизации, такие как мьютексы или семафоры, чтобы управлять доступом к оперативной памяти и предотвратить конфликты.
        </p>

        <b>160. Сравни как реализован ООП Go и Java</b>
        <p>
            В Java объектно-ориентированное программирование реализовано через классы и наследование, тогда как в Go используется составление (composition) и интерфейсы, что позволяет избежать проблем с многократным наследованием.
        </p>

        <b>161. Как устроена объектоориентированная модель в Go</b>
        <p>
            Объектно-ориентированная модель в Go основана на использовании структур (structs) и интерфейсов; методы могут быть привязаны к структурам, а интерфейсы определяют набор методов, которые должны быть реализованы.
        </p>

        <b>162. Почему встраивание — не наследование</b>
        <p>
            Встраивание в Go позволяет использовать поля и методы одного типа внутри другого, но это не является наследованием, так как не создается иерархия типов и не поддерживается полиморфизм.
        </p>

        <b>163. Какие есть способы написания обобщенного кода в Go</b>
        <p>
            Обобщенный код в Go можно писать с использованием интерфейсов, а также с помощью типа <code>any</code> (с версии Go 1.18), что позволяет создавать функции и структуры, работающие с разными типами данных.
        </p>

        <b>164. Какие известны виды контекстов в Go</b>
        <p>
            В Go известны контексты <code>context.Background()</code>, <code>context.TODO()</code>, а также дочерние контексты с помощью <code>context.WithCancel()</code>, <code>context.WithDeadline()</code> и <code>context.WithTimeout()</code>.
        </p>

        <b>165. Расскажи кейсы использования контекста</b>
        <p>
            Контекст используется для передачи значений между функциями, управления временем выполнения операций (например, таймауты), отмены операций и передачи метаданных (например, идентификаторов запросов).
        </p>

        <b>166. Какие есть возможности у создания дочернего контекста данных</b>
        <p>
            Дочерний контекст может наследовать значения родительского контекста, а также добавлять новые значения или устанавливать таймауты/дедлайны для управления временем выполнения операций.
        </p>

        <b>167. На какие уровни контекста распространяется отмена</b>
        <p>
            Отмена контекста распространяется на все дочерние контексты; если родительский контекст отменяется, все его дочерние контексты также будут отменены.
        </p>

        <b>168. Что такое сине-зеленый деплой(blue-green deployment)</b>
        <p>
            Сине-зеленый деплой — это метод развертывания приложений, при котором две идентичные среды (синие и зеленые) используются для переключения трафика между ними, что позволяет минимизировать время простоя и упростить откат изменений.
        </p>

        <b>169. Что такое Canary (канареечные развертывания)</b>
        <p>
            Канареечное развертывание — это метод развертывания новой версии приложения на небольшой части пользователей или серверов перед полным развертыванием, что позволяет выявить проблемы до того, как они затронут всех пользователей.
        </p>

        <b>170. Что такое Dark (скрытые) или А/В-развертывания</b>
        <p>
            Dark или A/B-развертывания — это методы тестирования различных версий приложения на разных группах пользователей для оценки их производительности и выбора наилучшей версии перед полным развертыванием.
        </p>

        <b>171. Что такое SLA</b>
        <p>
            SLA (Service Level Agreement) — это соглашение о уровне обслуживания, которое определяет ожидаемые уровни производительности и доступности услуг между поставщиком услуг и клиентом.
        </p>

        <b>172. Что такое SLO</b>
        <p>
            SLO (Service Level Objective) — это конкретные цели уровня обслуживания, которые определяют измеримые параметры производительности или доступности сервиса в рамках SLA.
        </p>

        <b>173. Что такое SLI</b>
        <p>
            SLI (Service Level Indicator) — это метрика, используемая для измерения уровня обслуживания в рамках SLO, позволяющая отслеживать качество предоставляемых услуг.
        </p>

        <b>174. Какие инструменты CI/CD известны</b>
        <p>
            Известные инструменты CI/CD включают Jenkins, GitLab CI/CD, CircleCI, Travis CI, Bamboo и GitHub Actions.
        </p>

        <b>175. Как обеспечить непрерывность и стабильность деплоя приложения</b>
        <p>
            Для обеспечения непрерывности и стабильности деплоя приложения необходимо использовать автоматизацию процессов развертывания, мониторинг производительности, тестирование на разных этапах и внедрение практик отката при возникновении ошибок.
        </p>

        <b>176. С какими проблемами при деплое продукта сталкивался, как митигировал</b>
        <p>
            Проблемы могут включать сбои в развертывании из-за несовместимости версий или ошибок конфигурации; для их mitigations можно использовать автоматизированные тесты перед деплоем и механизмы отката при возникновении ошибок.
        </p>

        <b>177. Как можно проверить тип интерфейса</b>
        <p>
            Для проверки типа интерфейса можно использовать оператор type assertion: <code>value, ok := myInterface.(ConcreteType)</code>, где <code>ConcreteType</code> — ожидаемый тип.
        </p>

        <b>178. Почему пустой интерфейс можно привести к любому типу</b>
        <p>
            Пустой интерфейс (<code>interface{}</code>) может содержать значение любого типа в Go, так как он не имеет методов; следовательно, любой тип может быть присвоен пустому интерфейсу без явного преобразования.
        </p>

        <b>179. Как пустой интерфейс связан с обычным</b>
        <p>
            Пустой интерфейс представляет собой обобщенный тип данных, который может хранить значения любых типов; обычные типы могут быть приведены к пустому интерфейсу благодаря его универсальности.
        </p>

        <b>180. Что может быть пустым интерфейсом</b>
        <p>
            Пустым интерфейсом может быть любое значение любого типа в Go — примитивные типы, структуры, массивы, срезы и даже другие интерфейсы.
        </p>

        <b>181. Зачем нужен пустой интерфейс</b>
        <p>
            Пустой интерфейс нужен для создания функций или структур, которые могут работать с любыми типами данных без необходимости их жесткого определения заранее.
        </p>

        <b>182. Что такое пустой интерфейс</b>
        <p>
            Пустой интерфейс (<code>interface{}</code>) — это интерфейс без методов; он может представлять любые данные в Go и используется для создания обобщенного кода.
        </p>

        <b>183. Какой есть способ проверки соответствия структуры интерфейсу</b>
        <p>
            Для проверки соответствия структуры интерфейсу можно использовать оператор type assertion или type switch для определения того, реализует ли структура необходимые методы интерфейса.
        </p>

        <b>184. Что такое closer и принцип его работы</b>
        <p>
            Closer — это интерфейс в Go с методом <code>Close()</code>, который используется для освобождения ресурсов; он обычно реализуется объектами для управления закрытием файловых дескрипторов или сетевых соединений.
        </p>

        <b>185. Чем отличается интерфейс Go от интерфейсов в других языках</b>
        <p>
            Интерфейсы в Go являются неявными; типы реализуют интерфейсы автоматически при наличии необходимых методов, тогда как в других языках требуется явное указание реализации интерфейса.
        </p>

        <b>186. Внутренее устройство интерфейса</b>
        <p>
            Интерфейс в Go состоит из двух частей: указателя на структуру данных (тип) и указателя на таблицу методов (методы), что позволяет определять методы для различных типов без необходимости явного указания.
        </p>

        <b>187. Что такое nil интерфейс</b>
        <p>
            Nil интерфейс — это интерфейс без значения; он указывает на отсутствие данных или объектов и может быть использован для проверки состояния переменной или объекта.
        </p>

        <b>188. Что такое type switch</b>
        <p>
            Type switch — это конструкция в Go для проверки типа переменной на соответствие нескольким типам; она позволяет выполнять разные действия в зависимости от фактического типа значения переменной.
        </p>

        <b>189. Как преобразовать интерфейс к другому типу</b>
        <p>
            Для преобразования интерфейса к другому типу используется оператор type assertion: <code>value := myInterface.(TargetType)</code>, где <code>TargetType</code> — желаемый тип данных.
        </p>

        <b>190. Где следует поместить описание интерфейса</b>
        <p>
            Описание интерфейса следует помещать в том же пакете, где он будет использоваться; это обеспечивает доступность его методов для других типов внутри пакета.
        </p>

        <b>191. Как сообщить компилятору, что наш тип реализует интерфейс</b>
        <p>
            Компилятору сообщается о реализации интерфейса путем определения методов этого интерфейса для нашего типа; компилятор автоматически проверяет соответствие типов во время компиляции.
        </p>

        <b>192. Что такое Go</b>
        <p>
            Go — это язык программирования с открытым исходным кодом, разработанный Google; он ориентирован на простоту, эффективность и поддержку параллелизма через горутины и каналы.
        </p>

        <b>193. Какие основные отличия есть у Go перед языками Java, Python</b>
        <p>
            Основные отличия Go от Java включают отсутствие наследования классов и использование композиций; по сравнению с Python Go предлагает статическую типизацию и более высокую производительность за счет компиляции в машинный код.
        </p>

        <b>194. Что такое пакеты (package) в Go</b>
        <p>
            Пакеты в Go — это единицы организации кода; они позволяют группировать связанные функции, типы и переменные для упрощения структуры приложения и повторного использования кода.
        </p>

        <b>195. Как создавать и импортировать пакеты</b>
        <p>
            Пакеты создаются путем размещения файлов с кодом в директории с именем пакета; импортировать пакеты можно с помощью ключевого слова <code>import "path/to/package"</code>.
        </p>

        <b>196. Что такое CI/CD</b>
        <p>
            CI/CD (Continuous Integration / Continuous Deployment) — это практика разработки программного обеспечения, которая включает автоматизацию сборки, тестирования и развертывания приложений для повышения качества кода и ускорения выпуска новых версий.
        </p>

        <b>197. Что такое линтеры (linters)</b>
        <p>
            Линтеры — это инструменты статического анализа кода, которые проверяют код на наличие ошибок стиля, потенциальных проблем или нарушений стандартов кодирования.
        </p>

        <b>198. Зачем нужны линтеры (linters)</b>
        <p>
            Линтеры помогают поддерживать качество кода, обеспечивая соблюдение стандартов оформления и выявляя потенциальные ошибки до выполнения программы.
        </p>

        <b>199. Как использовать линтеры (linters)</b>
        <p>
            Линтеры могут быть использованы путем установки соответствующего инструмента (например, golint или staticcheck) и запуска его на кодовой базе через командную строку или интеграцию с IDE.
        </p>

        <b>200. Что такое Prometheus</b>
        <p>
            Prometheus — это система мониторинга с открытым исходным кодом для сбора метрик времени выполнения приложений; она использует модель временных рядов для хранения данных и предоставляет мощный язык запросов для анализа метрик.
        </p>
        <b>201. Что такое Grafana</b>
        <p>
            Grafana — это платформа для визуализации и анализа метрик и логов, которая позволяет строить интерактивные графики и панели мониторинга, интегрируясь с различными источниками данных, такими как Prometheus, InfluxDB и другие.
        </p>

        <b>202. Зачем нужен Prometheus</b>
        <p>
            Prometheus нужен для сбора, хранения и анализа метрик времени выполнения приложений, обеспечивая мощные возможности мониторинга и оповещения на основе собранных данных.
        </p>

        <b>203. Зачем нужна Grafana</b>
        <p>
            Grafana нужна для визуализации данных, собранных из различных источников, таких как Prometheus, позволяя пользователям создавать красивые и информативные панели мониторинга для анализа производительности и состояния приложений.
        </p>

        <b>204. Go — императивный или декларативный</b>
        <p>
            Go является императивным языком программирования, так как он использует последовательные команды для описания шагов, необходимых для достижения результата, а не декларативный подход, где описываются только желаемые результаты.
        </p>

        <b>205. Главный недостаток стандартного логгера</b>
        <p>
            Главный недостаток стандартного логгера в Go заключается в том, что он не поддерживает многопоточную запись логов из разных горутин безопасно без дополнительной синхронизации.
        </p>

        <b>206. Есть ли для Go хороший ORM</b>
        <p>
            Да, для Go есть несколько хороших ORM, таких как GORM, sqlx и ent, которые упрощают работу с базами данных и предоставляют удобные интерфейсы для выполнения операций с данными.
        </p>

        <b>207. Стандартный набор метрик prometheus в Go-программе</b>
        <p>
            Стандартный набор метрик Prometheus в Go-программе включает метрики по времени выполнения запросов, количеству обработанных запросов, потреблению памяти и загрузке процессора.
        </p>

        <b>208. Какие преимущества у горутин над тредами</b>
        <p>
            Преимущества горутин над тредами включают меньшую накладную стоимость создания и управления, легкость в использовании (с помощью ключевого слова <code>go</code>) и более эффективное использование ресурсов благодаря модели управления конкурентностью в Go.
        </p>

        <b>209. Какие есть недостатки у горутин относительно тредов</b>
        <p>
            Недостатки горутин относительно тредов могут включать отсутствие контроля над планированием (например, при необходимости строгого приоритета) и сложность отладки при большом количестве конкурирующих горутин.
        </p>

        <b>210. Что можно делать с закрытым каналом</b>
        <p>
            С закрытым каналом можно только читать данные; попытка записи в закрытый канал приведет к панике, но чтение из него вернет оставшиеся значения до закрытия.
        </p>

        <b>211. Что делать, если канал интовый и был получен ноль</b>
        <p>
            Если из интового канала был получен ноль, необходимо проверить, был ли канал закрыт; если канал закрыт, это может означать, что больше нет доступных значений.
        </p>

        <b>212. Через какой канал возможна проверка работы горутины</b>
        <p>
            Проверка работы горутины возможна через канал, который используется для отправки сигналов о завершении работы или статуса выполнения горутины.
        </p>

        <b>213. Как закрыть канал</b>
        <p>
            Канал закрывается с помощью функции <code>close(myChannel)</code>, что предотвращает дальнейшую запись в этот канал и позволяет читателям узнать о завершении передачи данных.
        </p>

        <b>214. Какие действия можно производить с каналами</b>
        <p>
            С каналами можно производить действия по отправке и получению данных, а также их закрытию; каналы могут быть использованы для синхронизации между горутинами.
        </p>

        <b>215. Какие последствия чтения из закрытого канала</b>
        <p>
            Чтение из закрытого канала вернет оставшиеся значения до его закрытия; если канал пустой и закрыт, операция чтения вернет нулевое значение типа канала без паники.
        </p>

        <b>216. В каких случаях происходит deadlock</b>
        <p>
            Deadlock происходит, когда две или более горутины ожидают друг друга на ресурсы или операции, что приводит к тому, что ни одна из них не может продолжать выполнение.
        </p>

        <b>217. Что означает deadlock при работе с goroutine</b>
        <p>
            Deadlock при работе с горутинами означает состояние блокировки, когда одна или несколько горутин не могут продолжить выполнение из-за ожидания освобождения ресурсов или сигналов от других горутин.
        </p>

        <b>218. Что такое nil канал и что будет если писать и читать от туда</b>
        <p>
            Nil канал — это канал, который не инициализирован; попытка записать или прочитать из nil канала приведет к блокировке операции записи или чтения соответственно.
        </p>

        <b>219. Что будет если закрыть закрытый канал</b>
        <p>
            Если попытаться закрыть уже закрытый канал, это приведет к панике в программе; необходимо избегать повторного закрытия канала.
        </p>

        <b>220. Как расшифровывается аббревиатура ACID</b>
        <p>
            ACID расшифровывается как Atomicity (атомарность), Consistency (согласованность), Isolation (изоляция) и Durability (долговечность) — принципы, обеспечивающие надежность транзакций в базах данных.
        </p>

        <b>221. Какие бывают типы изоляции транзакций можешь назвать</b>
        <p>
            Типы изоляции транзакций включают Read Uncommitted, Read Committed, Repeatable Read и Serializable — каждый из которых определяет уровень видимости изменений между транзакциями.
        </p>

        <b>222. Какие бывают виды индексов</b>
        <p>
            Виды индексов включают уникальные индексы, составные индексы, полнотекстовые индексы и пространственные индексы — каждый из которых оптимизирует поиск данных по различным критериям.
        </p>

        <b>223. Что такое индексы в MySQL</b>
        <p>
            Индексы в MySQL — это структуры данных, которые ускоряют операции поиска строк в таблицах, позволяя базе данных быстро находить записи по заданным критериям.
        </p>

        <b>224. Для чего используют индексы</b>
        <p>
            Индексы используются для повышения производительности запросов к базе данных путем уменьшения времени поиска строк и оптимизации операций сортировки и фильтрации данных.
        </p>

        <b>225. Как создать индекс</b>
        <p>
            Индекс создается с помощью SQL-команды <code>CREATE INDEX index_name ON table_name (column1, column2,...);</code>, где указываются имя индекса и столбцы для индексации.
        </p>

        <b>226. Что такое составной индекс</b>
        <p>
            Составной индекс — это индекс, который охватывает более одного столбца таблицы; он позволяет эффективно выполнять запросы, которые фильтруют или сортируют данные по нескольким полям одновременно.
        </p>

        <b>227. Как создать составной индекс</b>
        <p>
            Составной индекс создается с помощью SQL-команды <code>CREATE INDEX index_name ON table_name (column1, column2);</code>, где <code>column1</code> и <code>column2</code> — это столбцы для индексации.
        </p>

        <b>228. Для чего используются составные индексы</b>
        <p>
            Составные индексы используются для оптимизации запросов, которые обращаются к нескольким столбцам одновременно, что позволяет значительно ускорить поиск и сортировку данных.
        </p>

        <b>229. Как использовать индексы в JOIN запросах Mysql</b>
        <p>
            Индексы в JOIN запросах используются для ускорения соединений между таблицами; они позволяют базе данных быстрее находить соответствующие строки по ключам соединения.
        </p>

        <b>230. Что такое частичные индексы</b>
        <p>
            Частичные индексы — это индексы, которые создаются только для подмножества строк таблицы на основе заданного условия; они помогают уменьшить объем хранимых данных и ускорить запросы к определенным строкам.
        </p>

        <b>231. Для чего используется частичный индекс</b>
        <p>
            Частичный индекс используется для оптимизации запросов к конкретным подмножествам данных в таблице, что позволяет снизить накладные расходы на хранение индекса и улучшить производительность запросов.
        </p>

        <b>232. Как создать частичный индекс</b>
        <p>
            Частичный индекс создается с помощью SQL-команды <code>CREATE INDEX index_name ON table_name (column1) WHERE condition;</code>, где <code>condition</code> определяет строки для индексации.
        </p>

        <b>233. В чем отличия InnoDB и MyISAM</b>
        <p>
            Основные отличия между InnoDB и MyISAM включают поддержку транзакций и внешних ключей в InnoDB, а также более высокую производительность чтения в MyISAM; InnoDB также обеспечивает лучшую целостность данных благодаря механизму блокировок на уровне строк.
        </p>

        <b>234. Возможен ли JOIN со вложенными запросами</b>
        <p>
            Да, JOIN со вложенными запросами возможен в MySQL; это позволяет объединять данные из нескольких таблиц с использованием результатов подзапросов для фильтрации или соединения данных.
        </p>

        <b>235. Что такое дедлоки (deadlock)</b>
        <p>
            Дедлоки (deadlock) — это ситуация в многопоточных системах, когда два или более потоков блокируют друг друга, ожидая освобождения ресурсов, что приводит к остановке выполнения всех вовлеченных потоков.
        </p>

        <b>236. Как избежать deadlock</b>
        <p>
            Чтобы избежать deadlock, следует использовать стратегию упорядочивания доступа к ресурсам, избегать долгих блокировок и применять тайм-ауты для операций блокировки.
        </p>

        <b>237. Что такое HAVING</b>
        <p>
            HAVING — это оператор SQL, который используется для фильтрации группировок данных после выполнения агрегатных функций; он позволяет задавать условия на агрегированные значения.
        </p>

        <b>238. Что делает HAVING</b>
        <p>
            HAVING фильтрует результаты группировки по условиям на агрегированные данные; он применяется после оператора GROUP BY для ограничения числа возвращаемых групп.
        </p>

        <b>239. Можно ли использовать HAVING без группировки данных?</b>
        <p>
            Да, можно использовать HAVING без группировки данных; однако в этом случае его применение будет эквивалентно WHERE с тем отличием, что HAVING применяется после агрегации.
        </p>

        <b>240. Что такое EXPLAIN?</b>
        <p>
            EXPLAIN — это команда SQL в MySQL, которая используется для получения информации о том, как будет выполнен запрос; она помогает анализировать планы выполнения запросов и оптимизировать производительность базы данных.
        </p>

        <b>241. Как узнать версию Mysql?</b>
        <p>
            Версию MySQL можно узнать с помощью команды <code>SELECT VERSION();</code>, которая возвращает текущую версию установленного сервера MySQL.
        </p>

        <b>242. Как можно оптимизировать ORDER BY RAND()?</b>
        <p>
            Для оптимизации ORDER BY RAND() можно использовать другие подходы, такие как выбор случайных значений через LIMIT с предварительной выборкой идентификаторов или использование переменной случайного числа для упрощения выборки.
        </p>

        <b>243. Как удалить индекс MySQL?</b>
        <p>
            Индекс MySQL удаляется с помощью команды <code>DROP INDEX index_name ON table_name;</code>, где <code>index_name</code> — имя удаляемого индекса и <code>table_name</code> — имя таблицы.
        </p>

        <b>244. Когда и зачем может пригодиться денормализация данных?</b>
        <p>
            Денормализация данных может пригодиться для повышения производительности чтения за счет уменьшения количества JOIN операций; она используется в случаях высокой нагрузки на чтение или необходимости ускорения доступа к данным.
        </p>

        <b>245. В чем отличие синхронной репликации от асинхронной? Какая подходит лучше для какого кейса?</b>
        <p>
            Синхронная репликация требует подтверждения записи на всех репликах перед завершением транзакции, обеспечивая высокую целостность данных; асинхронная репликация позволяет завершать транзакции быстрее за счет задержки синхронизации с репликами, что подходит для сценариев высокой доступности при меньших требованиях к целостности.</p>

        <b>246. Если индекс создан для 2-х колонок и запрос содержит только одну из них - будет ли он работать?</b>
        <p>
            Да, индекс будет работать для запроса, содержащего только одну из двух колонок; однако его эффективность может быть ниже по сравнению с использованием обеих колонок в условии запроса.</p>

        <b>247. Как устроен процесс удаления из конца и начала массива?</b>
        <p>
            Процесс удаления элемента из конца массива обычно требует изменения размера массива (если он динамический) или просто уменьшения счетчика элементов; удаление из начала массива требует сдвига всех последующих элементов на одну позицию влево.</p>

        <b>248. Какие знакомы методы разрешения коллизий?</b>
        <p>
            Методы разрешения коллизий включают цепочки (chaining), открытая адресация (open addressing) и двойное хеширование (double hashing), каждый из которых предлагает разные стратегии обработки конфликтов при вставке значений в хеш-таблицу.</p>

        <b>249. Какая синтетическая сложность получения элемента из слайса?</b>
        <p>
            Синтетическая сложность получения элемента из слайса составляет O(1), так как доступ к элементам осуществляется по индексу.</p>

        <b>250. В чем сложность удаления из начала внутри динамического массива (слайса)? </b>
        <p>
            Сложность удаления элемента из начала динамического массива (слайса) составляет O(n), так как требуется сдвиг всех последующих элементов на одну позицию влево.</p>
        <b>251. Как эффективно склеивать множество строк</b>
        <p>
            Эффективно склеивать множество строк в Go можно с помощью типа <code>strings.Builder</code>, который минимизирует количество выделений памяти, позволяя добавлять строки без создания промежуточных значений.
        </p>

        <b>252. По какому алгоритму растет slice</b>
        <p>
            Slice в Go растет по алгоритму удвоения размера, что означает, что при превышении текущей емкости выделяется новый массив, размер которого в два раза больше, и копируются данные из старого массива.
        </p>

        <b>253. Назови накрутку, при которой горутины могут кидать ошибки</b>
        <p>
            Накрутка, при которой горутины могут кидать ошибки, называется <code>panic</code>; она может произойти при возникновении непредвиденных ситуаций, таких как деление на ноль или выход за пределы массива.
        </p>

        <b>254. В чем разница шардирования и партиционирования</b>
        <p>
            Шардирование — это распределение данных по нескольким серверам для повышения производительности и доступности, в то время как партиционирование — это разбиение данных внутри одной базы данных на более мелкие части для оптимизации запросов.
        </p>

        <b>255. Какие знаешь алгоритмы балансировки нагрузки</b>
        <p>
            Алгоритмы балансировки нагрузки включают Round Robin, Least Connections, IP Hashing и Weighted Load Balancing, каждый из которых распределяет нагрузку по различным критериям.
        </p>

        <b>256. Что такое сага</b>
        <p>
            Сага — это паттерн управления транзакциями, который разбивает долгую транзакцию на последовательность локальных транзакций с возможностью отката каждой из них в случае ошибки.
        </p>

        <b>257. Какие сущности есть в планировщике</b>
        <p>
            В планировщике Go есть сущности такие как <code>goroutine</code>, <code>thread</code> и <code>m</code> (модель), которые управляют выполнением и распределением задач между потоками.
        </p>

        <b>258. Что такое Rest API</b>
        <p>
            Rest API — это архитектурный стиль для разработки веб-сервисов, который использует HTTP-запросы для выполнения операций CRUD (создание, чтение, обновление, удаление) над ресурсами.
        </p>

        <b>259. Что такое recover</b>
        <p>
            <code>recover</code> — это встроенная функция в Go, которая позволяет восстанавливать выполнение программы после паники, возвращая управление и предотвращая завершение программы.
        </p>

        <b>260. Что такое consumer group в kafka</b>
        <p>
            Consumer group в Kafka — это группа потребителей, которые работают совместно для обработки сообщений из одного или нескольких топиков, обеспечивая балансировку нагрузки и отказоустойчивость.
        </p>

        <b>261. Что такое уровни изоляции транзакций</b>
        <p>
            Уровни изоляции транзакций определяют степень видимости изменений одной транзакции другим; основные уровни включают Read Uncommitted, Read Committed, Repeatable Read и Serializable.
        </p>

        <b>262. Что такое триггер</b>
        <p>
            Триггер — это специальная процедура в базе данных, которая автоматически выполняется при определенных событиях (например, вставке, обновлении или удалении) на заданной таблице.
        </p>

        <b>263. Что такое нормализация</b>
        <p>
            Нормализация — это процесс организации данных в базе данных для уменьшения избыточности и обеспечения целостности данных путем разбиения таблиц на более мелкие и установления связей между ними.
        </p>

        <b>264. Чем stream отличается от unary</b>
        <p>
            Stream (поток) в контексте gRPC позволяет передавать множество сообщений между клиентом и сервером, тогда как unary (унарный) подразумевает обмен только одним сообщением за запрос.
        </p>

        <b>265. Чем mongo отличается от postgres</b>
        <p>
            MongoDB — это NoSQL документно-ориентированная база данных, которая хранит данные в формате JSON-подобных документов, тогда как PostgreSQL — это реляционная база данных с поддержкой SQL и структурированных данных.
        </p>

        <b>266. Чем юнит тесты отличаются от интеграционных</b>
        <p>
            Юнит тесты проверяют отдельные компоненты или функции в изоляции от остальной системы, тогда как интеграционные тесты проверяют взаимодействие между компонентами системы.
        </p>

        <b>267. Чем отличается merge от rebase</b>
        <p>
            Merge объединяет две ветки, создавая новый коммит слияния, а Rebase перемещает изменения одной ветки на вершину другой ветки, изменяя историю коммитов и делая ее линейной.
        </p>

        <b>268. Чем отличается конкурентность от параллелизма</b>
        <p>
            Конкурентность — это возможность выполнения нескольких задач одновременно (но не обязательно одновременно), тогда как параллелизм подразумевает фактическое одновременное выполнение нескольких задач на разных процессорах или ядрах.
        </p>

        <b>269. Какие есть средства обобщенного программирования</b>
        <p>
            Средства обобщенного программирования включают интерфейсы и обобщенные типы (generics), которые позволяют создавать функции и структуры, работающие с различными типами данных без дублирования кода.
        </p>

        <b>270. Что такое тип сумма и как ее реализовать</b>
        <p>
            Тип сумма — это тип данных, который может принимать значения из множества различных типов; в Go его можно реализовать с помощью интерфейсов и структур, которые содержат различные поля для разных типов.
        </p>

        <b>271. Как устроена файловая система Ext4</b>
        <p>
            Файловая система Ext4 использует журналы для обеспечения целостности данных, поддерживает большие объемы хранения, улучшенную производительность и эффективное управление метаданными через блоки и иноды.
        </p>

        <b>272. Что такое гит</b>
        <p>
            Git — это система управления версиями, которая позволяет отслеживать изменения в коде и координировать работу нескольких разработчиков над проектом, обеспечивая возможность отката к предыдущим версиям.
        </p>

        <b>273. Почему поиск в b-tree работает быстрее чем линейный перебор</b>
        <p>
            Поиск в B-tree работает быстрее линейного перебора благодаря своей структуре, которая обеспечивает логарифмическое время поиска за счет деления данных на узлы и упорядочивания их по ключам.
        </p>

        <b>274. Что такое воркстилинг</b>
        <p>
            Воркстилинг (work stealing) — это метод распределения задач между потоками или горутинами, при котором бездействующие потоки могут "украсть" задачи у занятых потоков для повышения общей производительности.
        </p>

        <b>275. Назови преимущества горутин перед потоками ОС</b>
        <p>
            Преимущества горутин включают меньшую накладную стоимость создания и управления по сравнению с потоками ОС, легкость синхронизации через каналы и возможность масштабирования на большое количество горутин без значительных затрат ресурсов.
        </p>

        <b>276. Назови агрегатные функции</b>
        <p>
            Агрегатные функции включают <code>SUM()</code>, <code>AVG()</code>, <code>COUNT()</code>, <code>MAX()</code>, <code>MIN()</code>, которые используются для вычисления значений на основе множества строк в базе данных.
        </p>

        <b>277. Куда смотреть если лагает сервер</b>
        <p>
            Если сервер лагает, стоит проверить использование CPU и памяти, нагрузку на диск, сетевые задержки и анализировать логи приложений для выявления узких мест или ошибок.
        </p>

        <b>278. Какие есть алгоритмы балансировки</b>
        <p>
            Алгоритмы балансировки включают Round Robin, Least Connections, IP Hashing, Random и Weighted Round Robin; они помогают равномерно распределять нагрузку между серверами или ресурсами.
        </p>

        <b>279. Какие данные не стоит индексировать</b>
        <p>
            Не стоит индексировать данные с высокой изменяемостью (например, временные метки), небольшие таблицы или колонки с низкой селективностью (например, булевы значения), так как это может ухудшить производительность.
        </p>

        <b>280. Какие виды join бывают</b>
        <p>
            Виды JOIN включают INNER JOIN, LEFT JOIN (или LEFT OUTER JOIN), RIGHT JOIN (или RIGHT OUTER JOIN), FULL OUTER JOIN и CROSS JOIN; каждый из них определяет способ объединения строк из различных таблиц.
        </p>

        <b>281. Какие виды индексов в postgres</b>
        <p>
            В PostgreSQL существуют виды индексов такие как B-tree индексы, Hash индексы, GiST индексы, GIN индексы и SP-GiST индексы; каждый из них оптимизирован для различных типов запросов и данных.
        </p>

        <b>282. Какие бывают способы оптимизации</b>
        <p>

            Способы оптимизации включают использование индексов, нормализацию данных, кэширование результатов запросов, оптимизацию SQL-запросов и использование партиционирования таблиц для улучшения производительности.
        </p>

        <b>283. Какие бывают примитивы синхронизации</b>
        <p>
            Примитивы синхронизации включают мьютексы (mutexes), семафоры (semaphores), каналы (channels) и условные переменные (condition variables), которые помогают управлять доступом к общим ресурсам в многопоточных приложениях.
        </p>

        <b>284. Как устроена многозадачность в Go</b>
        <p>
            Многозадачность в Go реализована через горутины и планировщик Go runtime; горутины легковесные и могут быть запущены параллельно с использованием одного или нескольких потоков операционной системы.
        </p>

        <b>285. Как устроена куча</b>
        <p>
            Куча (heap) — это область памяти для динамического выделения памяти; она управляется системой с помощью алгоритмов аллокации и деаллокации памяти для хранения объектов переменной длины во время выполнения программы.
        </p>

        <b>286. Как работает поиск по дереву</b>
        <p>
            Поиск по дереву осуществляется путем сравнения ключа с корнем дерева и рекурсивного перехода либо в левое поддерево (если ключ меньше), либо в правое поддерево (если ключ больше), пока не будет найден нужный элемент или достигнут конец дерева.
        </p>

        <b>287. Как можно реализовать сет в Go</b>
        <p>
            Сет в Go можно реализовать с помощью мапы (map) с булевыми значениями; ключи мапы будут представлять элементы множества, а значение true будет указывать на их наличие в множестве.
        </p>

        <b>288. Из каких частей состоит http запрос</b>
        <p>
            HTTP запрос состоит из метода (например, GET или POST), URL-адреса ресурса, заголовков (headers) и тела запроса (body), которое содержит данные для передачи на сервер.
        </p>

        <b>289. Зачем синхронизировать доступ данных</b>
        <p>
            Синхронизация доступа к данным необходима для предотвращения гонок данных (data races) и обеспечения целостности данных при одновременном доступе к ним из нескольких горутин или потоков.
        </p>

        <b>290. Зачем нужны таймауты при http запросах</b>
        <p>
            Таймауты при HTTP запросах нужны для предотвращения зависания приложения при ожидании ответа от сервера; они помогают контролировать время ожидания и обеспечивают возможность обработки ошибок соединения.
        </p>

        <b>291. Зачем нужно кэширование</b>
        <p>
            Кэширование нужно для повышения производительности приложения путем хранения часто запрашиваемых данных в быстрой памяти; это уменьшает время доступа к данным и снижает нагрузку на базу данных или другие ресурсы.
        </p>

        <b>292. Зачем нужен foreign key</b>
        <p>
            Foreign key (внешний ключ) нужен для обеспечения ссылочной целостности между таблицами базы данных; он гарантирует, что значения одного столбца соответствуют значениям другого столбца в связанной таблице.
        </p>

        <b>293. Для чего нужны оконные функции</b>
        <p>
            Оконные функции нужны для выполнения вычислений над набором строк с учетом текущей строки; они позволяют выполнять агрегатные операции без группировки результатов запроса.
        </p>

        <b>294. Сколько весит слайс в байтах</b>
        <p>
            Слайс в Go весит 24 байта на 64-битной архитектуре: 8 байт для указателя на массив, 8 байт для длины слайса и 8 байт для емкости слайса.</p>

        <b>295. В чем сходство и отличие обычного и абстрактного класса?</b>
        <p>
            Сходство обычного класса и абстрактного заключается в том, что оба могут содержать методы и свойства; отличие состоит в том, что абстрактный класс не может быть инстанцирован напрямую и может содержать абстрактные методы без реализации.</p>

        <b>296. Сколько весит мапа в байтах?</b>
        <p>
            Мапа в Go имеет фиксированный размер заголовка 8 байт на 64-битной архитектуре плюс дополнительное пространство для хранения ключей и значений; общий размер зависит от количества элементов.</p>

        <b>297. Как называется структура, которая копирует, когда что-либо передаешь?</b>
        <p>
            Структура, которая копирует при передаче значений называется "Value Semantics"; она создает копию объекта вместо передачи ссылки на оригинал.</p>
        <b>298. Какой концепт конструкция defer помогает реализовывать?</b>
        <p>
            Конструкция <code>defer</code> помогает реализовывать концепт "отложенного выполнения", позволяя выполнять определенные действия (например, освобождение ресурсов) после завершения функции независимо от того, как она завершилась.</p>

        <b>299. Как устроен runtime в Go?</b>
        <p>
            Runtime в Go управляет выполнением программы: он отвечает за планирование горутин на потоках ОС, управление памятью через сборщик мусора и обработку исключений.</p>

        <b>300. В какой момент инициализированное значение переменной передается в defer, как это связано с именованием функции?</b>
        <p>
            Инициализированное значение переменной передается в defer во время вызова функции; если переменная переименовывается или изменяется до вызова defer, то defer будет использовать последнее присвоенное значение.</p>
        <b>301. Что такое сериализация</b>
        <p>
            Сериализация — это процесс преобразования структуры данных или объекта в формат, который может быть сохранен или передан по сети, например, в JSON или бинарный формат.
        </p>

        <b>302. Зачем нужна сериализация</b>
        <p>
            Сериализация нужна для сохранения состояния объектов, передачи данных между различными системами или компонентами и для хранения данных в файлах или базах данных.
        </p>

        <b>303. Как работает сборщик мусора в Go</b>
        <p>
            Сборщик мусора в Go использует алгоритм маркировки и очистки для автоматического управления памятью, отслеживая неиспользуемые объекты и освобождая память, когда они больше не нужны.
        </p>

        <b>304. Расскажи про планирование goroutine</b>
        <p>
            Планирование goroutine в Go осуществляется через встроенный планировщик, который распределяет выполнение горутин по доступным потокам операционной системы, обеспечивая эффективное использование ресурсов.
        </p>

        <b>305. Что такое runtime (планировщик scheduler)</b>
        <p>
            Runtime (планировщик) в Go — это компонент, который управляет выполнением горутин, распределяет их по потокам и отвечает за управление памятью и сборку мусора.
        </p>

        <b>306. Кто управляет горутинами</b>
        <p>
            Горутинами управляет Go runtime, который отвечает за их создание, планирование и завершение, а также за распределение ресурсов между ними.
        </p>

        <b>307. Какой тип многозадачности используется в Go и какой был до версии Go 1.15</b>
        <p>
            В Go используется кооперативная многозадачность с планированием горутин; до версии Go 1.15 использовалась модель с меньшей эффективностью управления потоками, что привело к улучшениям в новой версии.
        </p>

        <b>308. Где переменная находится при ее выделении в горутине</b>
        <p>
            Переменная при выделении в горутине находится в куче (heap) или на стеке (stack), в зависимости от ее размера и времени жизни; маленькие переменные могут выделяться на стеке, а большие — в куче.
        </p>

        <b>309. Какие есть правила при выделении переменной в горутине</b>
        <p>
            При выделении переменной в горутине необходимо учитывать область видимости переменной и избегать гонок данных, используя синхронизацию (например, мьютексы или каналы).
        </p>

        <b>310. Где аллоцируется память для горутин</b>
        <p>
            Память для горутин аллоцируется в куче (heap) для хранения их контекста выполнения и локальных переменных; стек горутины может быть динамически изменен по мере необходимости.
        </p>

        <b>311. Какова осведомленность о сборщике мусора в Go</b>
        <p>
            Осведомленность о сборщике мусора в Go минимальна; программисты не управляют памятью вручную и могут полагаться на автоматическую сборку мусора для освобождения неиспользуемых объектов.
        </p>

        <b>312. Как называется механизм сборки мусора</b>
        <p>
            Механизм сборки мусора в Go называется "mark-and-sweep" (маркировка и очистка), который маркирует активные объекты и затем очищает неиспользуемые.
        </p>

        <b>313. Как устроены горутины, сколько памяти они занимают в стеке</b>
        <p>
            Горутины представляют собой легковесные потоки, которые используют динамический стек; начальный размер стека составляет 2 КБ и может увеличиваться по мере необходимости.
        </p>

        <b>314. Сколько весит пустая строка в байтах</b>
        <p>
            Пустая строка в Go занимает 16 байт на 64-битной системе: 8 байт для указателя на данные и 8 байт для длины строки.
        </p>

        <b>315. Сколько весит число в байтах</b>
        <p>
            Размер числа в Go зависит от его типа: int занимает 8 байт на 64-битной системе, а float64 — также 8 байт; другие типы могут занимать меньшее количество байт.
        </p>

        <b>316. Расскажи о GMP паттерне</b>
        <p>
            GMP паттерн (Goroutines, Mutexes, and Channels) описывает модель параллелизма в Go, где горутины выполняют задачи, мьютексы обеспечивают синхронизацию доступа к данным, а каналы используются для обмена данными между горутинами.
        </p>

        <b>317. Сколько очередей в паттерне</b>
        <p>
            В GMP паттерне обычно используется несколько очередей: одна для горутин, одна для мьютексов и одна или несколько для каналов, что позволяет эффективно управлять параллельными задачами.
        </p>
        <b>318. С какими паттернами проектирования знакомы</b>
        <p>
            Знаком с паттернами проектирования такими как Singleton, Factory, Builder, Observer, Strategy и Decorator, которые помогают организовать код и улучшить его читаемость и поддержку.
        </p>

        <b>319. Расскажи про паттерн Builder(Строитель)</b>
        <p>
            Паттерн Builder (Строитель) позволяет создавать сложные объекты пошагово; он отделяет процесс создания объекта от его представления, что упрощает создание различных вариантов объектов.
        </p>

        <b>320. Расскажи про паттерн Factory(Фабрика)</b>
        <p>
            Паттерн Factory (Фабрика) предоставляет интерфейс для создания объектов без указания конкретных классов; это позволяет инкапсулировать логику создания объектов и улучшает гибкость кода.
        </p>

        <b>321. Расскажи про паттерн Singleton(Одиночка)</b>
        <p>
            Паттерн Singleton (Одиночка) гарантирует, что класс имеет только один экземпляр и предоставляет глобальную точку доступа к этому экземпляру; это полезно для управления ресурсами или состоянием приложения.
        </p>

        <b>322. Расскажи, какой паттерн использовал в продукте/своем коде</b>
        <p>
            В своем коде использовал паттерн Factory для создания объектов конфигурации; это позволило упростить процесс создания различных конфигураций без дублирования кода.
        </p>

        <b>323. Знакомы ли с концепцией 12FA для проектирования SaaS приложений</b>
        <p>
            Да, знаком с концепцией 12FA (12-Factor App), которая предлагает принципы разработки SaaS приложений для обеспечения портативности, масштабируемости и удобства развертывания.
        </p>

        <b>324. Зачем используется дополнительный блок фигурных скобок в функции</b>
        <p>
            Дополнительный блок фигурных скобок в функции используется для ограничения области видимости переменных; это позволяет избежать конфликтов имен и управлять временем жизни переменных.
        </p>

        <b>325. Что такое замыкание</b>
        <p>
            Замыкание — это функция, которая захватывает и сохраняет доступ к переменным из своей внешней области видимости даже после завершения выполнения внешней функции.
        </p>

        <b>326. Что такое захват переменной</b>
        <p>
            Захват переменной происходит, когда функция (например, замыкание) использует переменную из своей внешней области видимости; это позволяет функции сохранять состояние между вызовами.
        </p>

        <b>327. Какое поведение по умолчанию используется в Golang при передаче в функцию</b>
        <p>
            По умолчанию в Go используется передача по значению; это означает, что при передаче аргумента в функцию создается копия значения.
        </p>

        <b>328. Сколько можно возвращать значений из функции</b>
        <p>
            В Go можно возвращать любое количество значений из функции; это может быть как одно значение, так и несколько значений через запятую.
        </p>

        <b>329. Как сделать свои методы для пакета</b>
        <p>
            Для создания своих методов для пакета нужно определить функции с заглавной буквы внутри файла пакета; это сделает их экспортируемыми и доступными из других пакетов.
        </p>

        <b>330. Что находится перед названием метода</b>
        <p>
            Перед названием метода находится тип (структура), к которому этот метод принадлежит; это определяет контекст вызова метода на экземпляре структуры.
        </p>

        <b>331. Что такое метод? Как они выглядят?</b>
        <p>
            Метод — это функция, связанная с конкретным типом (обычно структурой); он определяется с использованием синтаксиса <code>func (receiver Type) MethodName(params) returnType {}</code>.
        </p>

        <b>332. Как передаются параметры в функцию по указателю или по значению?</b>
        <p>
            Параметры передаются по значению по умолчанию; чтобы передать параметр по указателю, нужно использовать * перед типом параметра и передавать адрес переменной с помощью &.
        </p>

        <b>333. Как прочитать строку в виде иероглифов, кириллицы и т.д.</b>
        <p>
            Для чтения строки с поддержкой иероглифов и кириллицы нужно использовать кодировку UTF-8; Go поддерживает эту кодировку по умолчанию при работе со строками.
        </p>

        <b>334. Какие отличия у быстрого объявления и объявления через var?</b>
        <p>
            Быстрое объявление переменной с помощью := автоматически определяет тип переменной на основе присваиваемого значения, тогда как объявление через var требует явного указания типа переменной.
        </p>

        <b>335. У ресивера имеется звёздочка - что это значит?</b>
        <p>
            Звездочка у ресивера метода обозначает, что метод является методом указателя; это позволяет методу изменять состояние объекта (структуры), на который указывает ресивер.
        </p>

        <b>336. Какой вес у пустой структуры?</b>
        <p>
            Пустая структура (struct{}) занимает 0 байт памяти в Go; она используется для создания типов без данных или как маркеры.
        </p>

        <b>337. Что из себя представляет тип данных string в языке Golang?</b>
        <p>
            Тип данных string в Go представляет собой неизменяемую последовательность байтов UTF-8; он хранит длину строки и указатель на данные строки.
        </p>

        <b>338. Можно ли изменить определенный символ в строке?</b>
        <p>
            Нельзя изменить определенный символ в строке напрямую из-за неизменяемости строк; вместо этого нужно создать новую строку с нужными изменениями.
        </p>

        <b>339. Что происходит при склеивании строк?</b>
        <p>
            При склеивании строк создается новая строка, которая содержит объединенные значения; это приводит к созданию нового массива байтов с копированием данных из исходных строк.
        </p>

        <b>340. Как можно оперировать строками?</b>
        <p>
            Строками можно оперировать с помощью встроенных функций пакета strings, таких как Concat, Join, Split, а также используя оператор + для конкатенации.
        </p>

        <b>341. Что будет если сложить строки?</b>
        <p>
            Если сложить строки с помощью оператора +, будет создана новая строка, содержащая объединенные значения обеих строк; исходные строки останутся неизменными.
        </p>

        <b>342. Как определить количество символов для строки?</b>
        <p>
            Количество символов в строке можно определить с помощью функции len(), которая возвращает количество байтов строки; для подсчета количества ругих символов следует использовать пакет utf8.
        </p>

        <b>343. Какие есть нюансы при итерации по строке?</b>
        <p>
            При итерации по строке необходимо учитывать, что строки состоят из байтов UTF-8; лучше использовать for range, чтобы корректно обрабатывать многобайтовые символы.
        </p>

        <b>344. Как эффективно склеивать строки (конкатенация строк)?</b>
        <p>
            Эффективно склеивать строки можно с помощью типа strings.Builder, который минимизирует количество выделений памяти при добавлении строк.
        </p>

        <b>345. Отличие uint от int?</b>
        <p>
            Отличие между uint и int заключается в том, что int — это знаковый тип целого числа (может быть положительным или отрицательным), а uint — беззнаковый тип (может быть только положительным).
        </p>

        <b>346. Что такое обычный int и какие есть нюансы его реализации?</b>
        <p>
            Обычный int — это целочисленный тип данных с размером, зависящим от платформы (32 или 64 бита); важно учитывать переполнение при арифметических операциях с большими числами.
        </p>

        <b>347. Как преобразовать строку в int и наоборот?</b>
        <p>
            Для преобразования строки в int можно использовать функцию strconv.Atoi(), а для преобразования int в строку — функцию strconv.Itoa().
        </p>

        <b>348. Расскажи о себе в Golang.</b>
        <p>
            Я опытный разработчик на Golang с навыками работы с веб-приложениями, микросервисами и базами данных; активно использую горутины и каналы для параллелизма и оптимизации кода.
        </p>

        <b>349. Какой опыт работы в Golang?</b>
        <p>
            У меня есть опыт работы с Golang более трех лет; я разрабатывал RESTful API, работал с базами данных PostgreSQL и MongoDB, а также использовал gRPC для межсервисного взаимодействия.
        </p>


    </div>



    <!-- ExtraContentModal -->
    <div class="modal fade" id="ExtraContentModal" tabindex="-1" aria-labelledby="exampleModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h1 class="modal-title fs-5" id="exampleModalLabel">Добавить ссылку на доп. матераил</h1>
                </div>
                <div class="modal-body">
                    <form action="5888.html" method="POST">
                        <input type="hidden" name="csrfmiddlewaretoken" value="RkkFCCaSF1k7aA5y6V5rEE1xl074cgW0cvdRp3zc4vwnPlhy1pHIVecayaO0IfLh">
                        <div class="mb-3">
                            <label for="id_content-title" class="col-form-label">Название: </label>
                            <input type="text" name="content-title" class="form-control" maxlength="255" required id="id_content-title">
                        </div>
                        <div class="mb-3">
                            <label for="id_content-url" class="col-form-label">Ссылка: </label>
                            <input type="url" name="content-url" class="form-control" required id="id_content-url">
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Закрыть</button>
                            <button type="submit" class="btn btn-primary">Добавить</button>
                        </div>
                    </form>
                </div>
            </div>
        </div>
    </div>

    <!-- VideoAnswerModal -->
    <div class="modal fade" id="VideoAnswerModal" tabindex="-1" aria-labelledby="VideoAnswerModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h1 class="modal-title fs-5" id="VideoAnswerModalLabel">Добавить ответ из mock-собесов</h1>
                </div>
                <div class="modal-body">
                    <form action="5888.html" method="POST">
                        <input type="hidden" name="csrfmiddlewaretoken" value="RkkFCCaSF1k7aA5y6V5rEE1xl074cgW0cvdRp3zc4vwnPlhy1pHIVecayaO0IfLh">
                        <div class="mb-3">
                            <label for="id_video-title" class="col-form-label">Название видео: </label>
                            <input type="text" name="video-title" class="form-control" maxlength="255" required id="id_video-title">
                        </div>
                        <div class="mb-3">
                            <label for="id_video-url" class="col-form-label">Ссылка на момент ответа: </label>
                            <input type="url" name="video-url" class="form-control" required id="id_video-url">
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Закрыть</button>
                            <button type="submit" class="btn btn-primary">Добавить</button>
                        </div>
                    </form>
                </div>
            </div>
        </div>
    </div>



</main>
<script>hljs.highlightAll();</script>
</body>

<div class="container">
    <footer class="py-3 my-4">
        <p class="text-center nav-item nav-link px-2 text-body-secondary text-decoration-none text-reset fs-6">☀️interviews...</p>
        <ul class="nav justify-content-center pb-1 mb-1">
            <!--          <li class="nav-item nav-link px-2 text-body-secondary text-decoration-none text-reset fs-6">☀️interviews...</li>-->
            <li class="nav-item"><a href="https://t.me/+3xsbmERSOP0wMWRi" target="_blank" class="nav-link px-2 text-body-secondary text-decoration-none text-reset fs-6"><i class="bi bi-telegram"></i></a></li>
            <li class="nav-item"><a href="https://www.youtube.com/@goingtoit" target="_blank" class="nav-link px-2 text-body-secondary text-decoration-none text-reset fs-6"><i class="bi bi-youtube"></i></a></li>
            <li class="nav-item"><a href="https://github.com/kivaiko" target="_blank" class="nav-link px-2 text-body-secondary text-decoration-none text-reset fs-6"><i class="bi bi-github"></i></a></li>
            <li class="nav-item"><a href="https://www.linkedin.com/in/kivaiko/" target="_blank" class="nav-link px-2 text-body-secondary text-decoration-none text-reset fs-6"><i class="bi bi-linkedin"></i></a></li>
            <li class="nav-item"><a href="https://www.instagram.com/kivaiyko/" target="_blank" class="nav-link px-2 text-body-secondary text-decoration-none text-reset fs-6"><i class="bi bi-instagram"></i></a></li>
            <li class="nav-item"><a href="https://twitter.com/kivaiyko" target="_blank" class="nav-link px-2 text-body-secondary text-decoration-none text-reset fs-6"><i class="bi bi-twitter"></i></a></li>
        </ul>
    </footer>
</div>
</html>
