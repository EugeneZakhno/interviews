<!DOCTYPE html>

<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-9ndCyUaIbzAi2FUVXJi0CjmCapSmO7SnpJef0486qhLnuZ2cdeRhO02iuK6FUUVM" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js" integrity="sha384-geWF76RCwLtnZ8qwWowPQNguL3RmwHVBC9FhGdlKrxdiJJigb/j/68SIy3Te4Bkz" crossorigin="anonymous"></script>
    <link rel="apple-touch-icon" sizes="152x152" href="../static/favicon/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../static/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../static/favicon/favicon-16x16.png">
    <link rel="manifest" href="../static/favicon/site.webmanifest">
    <link rel="mask-icon" href="../static/favicon/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="theme-color" content="#ffffff">
    <script type="text/javascript" src="../static/ckeditor/ckeditor-init.js"></script>
    <script type="text/javascript" src="../static/ckeditor/ckeditor/ckeditor.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>

    <!-- and it's easy to individually load additional languages -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/go.min.js"></script>

    <title>
        Что такое обычный int и какие есть нюансы его реализации
    </title>
    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
            new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
        'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KFVDXM9B');</script>
    <!-- End Google Tag Manager -->

    <meta name="yandex-verification" content="fbc87e7cf8354d83" />
</head>

<body style="min-height: 100vh; display: flex; flex-direction: column; justify-content: space-between">
<!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-KFVDXM9B"
                  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->
<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
    (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
        m[i].l=1*new Date();
        for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}
        k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
    (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

    ym(95314788, "init", {
        clickmap:true,
        trackLinks:true,
        accurateTrackBounce:true
    });
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/95314788" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->
<nav class="navbar navbar-expand-lg" style="background-color: #e3f2fd;">
    <div class="container">
        <div class="fs-2 me-2 nav-link"><a class="nav-link navbar-brand fs-4" href="../index.html">☀️interviews</a></div>
        <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarSupportedContent">
            <ul class="navbar-nav me-auto mb-2 mb-lg-0">
                <li class="nav-item active">
                    <a class="nav-link" href="../index.html">Вопросы</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="../mock.html">Собесы</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="../mentor.html">Менторы</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="../analytic.html">Требования</a>
                </li>
            </ul>
            <a class="btn btn-sm btn btn-danger" href="https://t.me/+Korj4gSMfStlNDAy" target="_blank" type="button"><i class="bi bi-lock"></i> Приватная база собесов</a>
        </div>
    </div>
</nav>
<main class="container" style="flex: 1 1 auto;">


    <div class="row">
        <div class="col">
            <h1>1. Основы языка (Fundamentals)</h1> <br>
            <h2>• Типы данных:</h2>
            <b>1. Какие основные типы данных в Go?</b>
            <p>В Go есть несколько основных типов данных:</p>
            <ul>
                <li><strong>int</strong>: Целочисленный тип, размер которого зависит от платформы (32 или 64 бита).</li>
                <li><strong>uint</strong>: Беззнаковый целочисленный тип, также зависит от платформы.</li>
                <li><strong>float64</strong>: Числовой тип с плавающей запятой двойной точности (64 бита).</li>
                <li><strong>string</strong>: Тип для работы с текстовыми строками. Строки неизменяемы.</li>
                <li><strong>bool</strong>: Логический тип, может принимать значения <code>true</code> или <code>false</code>.</li>
                <li><strong>struct</strong>: Комплексный тип, который позволяет объединять различные типы данных в одну структуру.</li>
                <li><strong>slice</strong>: Динамический массив, который может изменять свой размер.</li>
                <li><strong>map</strong>: Коллекция пар "ключ-значение", где ключи уникальны.</li>
                <li><strong>chan</strong>: Тип для работы с каналами, используемыми для синхронизации и передачи данных между горутинами.</li>
                <li><strong>interface</strong>: Тип, который определяет набор методов; позволяет работать с различными типами через общий интерфейс.</li>
            </ul>

            <b>2. В чем разница между int и uint?</b>
            <p><strong>int</strong>: Это знаковый целочисленный тип, который может хранить как положительные, так и отрицательные значения.</p>
            <p><strong>uint</strong>: Это беззнаковый целочисленный тип, который может хранить только положительные значения (включая 0). Размер обоих типов зависит от платформы (32 или 64 бита). При использовании <code>uint</code> вы не сможете хранить отрицательные числа, но сможете использовать весь диапазон положительных значений.</p>

            <b>3. Что такое rune? Чем отличается от byte?</b>
            <p><strong>rune</strong>: Это тип данных, представляющий один символ в кодировке UTF-8. Он фактически является псевдонимом для типа <code>int32</code>, что позволяет хранить 4 байта информации и поддерживать символы из различных языков.</p>
            <p><strong>byte</strong>: Это тип данных, представляющий один байт информации, и является псевдонимом для типа <code>uint8</code>. Он используется для работы с сырыми данными и представляет собой 8-битное значение. Основное отличие заключается в том, что <code>rune</code> может представлять символы Unicode, тогда как <code>byte</code> ограничен одним байтом.</p>

            <b>4. Что такое string в Go? Неизменяемость строк.</b>
            <p>Строка (<code>string</code>) в Go — это последовательность байтов, которая обычно используется для представления текста. Строки в Go являются неизменяемыми, что означает, что после создания строки ее содержимое не может быть изменено. Любые операции, которые выглядят как изменения строки (например, конкатенация), на самом деле создают новую строк.</p>

            <b>5. Что такое nil? Для каких типов данных nil является нулевым значением?</b>
            <p><code>nil</code> — это специальное значение в Go, которое обозначает отсутствие значения или указателя. Оно может использоваться с указателями, срезами, картами, каналами и интерфейсами. Для этих типов данных <code>nil</code> является нулевым значением, что означает, что они не указывают на какой-либо объект или значение.</p>

            <b>6. Что такое iota? Где он используется?</b>
            <p><code>iota</code> — это специальная идентификаторная константа в Go, которая используется для создания последовательных значений. Она автоматически увеличивается на единицу при каждой новой строке констант в блоке <code>const</code>. Обычно <code>iota</code> используется для создания перечислений или для задания последовательных значений константам.</p>
            <p>Пример использования:</p>
            <pre><code>const (
                 A = iota // A = 0
                 B        // B = 1
                 C        // C = 2 )</code></pre>

            <b>7. Как объявить константу?</b>
            <p>Константы в Go объявляются с помощью ключевого слова <code>const</code>. Пример объявления константы:</p>
            <pre><code>const Pi = 3.14
const Greeting = "Hello, World!"</code></pre>
            <p>Вы также можете объявлять несколько констант одновременно:</p>
            <pre><code>
                const (
                  A = 1
                  B = 2
                  C = "Hello"
                )</code></pre>
            <h2>• Переменные:</h2>
            <b>1. В чем разница между объявлением переменной с использованием <code>var</code> и <code>:=</code>?</b>
            <p>Объявление переменной с использованием <code>var</code> и оператором <code>:=</code> имеет несколько отличий:</p>
            <ul>
                <li><strong><code>var</code></strong>: Это явное объявление переменной. Оно может использоваться для объявления переменных на уровне пакета или функции. Например:</li>
                <pre><code>var x int = 10</code></pre>
                <li><strong><code>:=</code></strong>: Это короткое объявление переменной, которое используется внутри функции и позволяет одновременно объявлять и инициализировать переменную. При этом тип переменной выводится автоматически. Например:</li>
                <pre><code>x := 10</code></pre>
                <li>Важно отметить, что оператор <code>:=</code> не может использоваться для переобъявления переменной, которая уже была объявлена в той же области видимости.</li>
            </ul>

            <b>2. Что такое нулевое значение переменной?</b>
            <p>Нулевое значение переменной — это значение, которое автоматически присваивается переменной при ее объявлении, но до инициализации. В Go каждое значение имеет свое нулевое значение:</p>
            <ul>
                <li><strong>int</strong>: 0</li>
                <li><strong>float64</strong>: 0.0</li>
                <li><strong>bool</strong>: false</li>
                <li><strong>string</strong>: "" (пустая строка)</li>
                <li><strong>slice, map, channel, interface, pointer</strong>: nil</li>
            </ul>

            <b>3. Как объявить несколько переменных одного типа в одной строке?</b>
            <p>В Go можно объявить несколько переменных одного типа в одной строке, используя запятую. Пример:</p>
            <pre><code>var a, b, c int = 1, 2, 3</code></pre>
            <p>Также можно использовать короткое объявление:</p>
            <pre><code>x, y := 4, 5</code></pre>

            <b>4. Что такое область видимости переменной?</b>
            <p>Область видимости переменной определяет, где в коде эта переменная доступна для использования. В Go область видимости может быть:</p>
            <ul>
                <li><strong>Глобальная (пакетная):</strong> Переменные, объявленные вне функций, доступны во всем пакете.</li>
                <li><strong>Локальная:</strong> Переменные, объявленные внутри функции, доступны только в этой функции.</li>
                <li><strong>Область видимости блока:</strong> Переменные, объявленные внутри блока (например, в условии или цикле), доступны только внутри этого блока.</li>
            </ul>
            <p>Важно понимать область видимости для правильного использования переменных и избежания конфликтов имен.</p>

            <h2>• Операторы:</h2>
            <b>1. Какие арифметические, логические и побитовые операторы есть в Go?</b>
            <p>
                <details>
          <summary>В Go доступны следующие арифметические операторы: +, -, *, /, %,&&, ||, !, &, |, ^, &lt;&lt;, &gt;&gt;</summary>
                <p>
            <ul>
                <li><code>+</code> — сложение</li>
                <li><code>-</code> — вычитание</li>
                <li><code>*</code> — умножение</li>
                <li><code>/</code> — деление</li>
                <li><code>%</code> — остаток от деления</li>
            </ul>
            </p>
            <p>
                Логические операторы:
            <ul>
                <li><code>&&</code> — логическое И</li>
                <li><code>||</code> — логическое ИЛИ</li>
                <li><code>!</code> — логическое НЕ</li>
            </ul>
            </p>
            <p>
                Побитовые операторы:
            <ul>
                <li><code>&</code> — побитовое И</li>
                <li><code>|</code> — побитовое ИЛИ</li>
                <li><code>^</code> — побитовое исключающее ИЛИ (XOR)</li>
                <li><code>&lt;&lt;</code> — побитовый сдвиг влево</li>
                <li><code>&gt;&gt;</code> — побитовый сдвиг вправо</li>
            </ul>
            </p>
            </details>
            <b>2. Какие операторы сравнения есть в Go?</b>
            <p>
                <details>
          <summary>В Go доступны следующие операторы сравнения: ==, !=, &gt;, &lt;, &gt;=, &lt;=</summary>
            <ul>
                <li><code>==</code> — равенство</li>
                <li><code>!=</code> — неравенство</li>
                <li><code>&gt;</code> — больше</li>
                <li><code>&lt;</code> — меньше</li>
                <li><code>&gt;=</code> — больше или равно</li>
                <li><code>&lt;=</code> — меньше или равно</li>
            </ul>
            </details>
            </p>


            <h2>• Управляющие конструкции:</h2>
            <b>1. Как работает оператор if в Go? Можно ли использовать if без else?</b>
            <p>
                Оператор <code>if</code> в Go используется для выполнения блока кода, если условие истинно. Синтаксис выглядит следующим образом:
            </p>
            <pre><code>if условие {
    // код, выполняемый если условие истинно
}</code></pre>
            <p>
                Да, оператор <code>if</code> может использоваться без <code>else</code>. Например:
            </p>
            <pre><code>if x > 0 {
    fmt.Println("x положительное")
}</code></pre>

            <b>2. Как работает оператор switch? В чем его отличие от if-else if-else?</b>
            <p>
                Оператор <code>switch</code> позволяет выполнять разные блоки кода в зависимости от значения выражения. Он упрощает чтение кода по сравнению с цепочкой <code>if-else if-else</code>. Пример использования:
            </p>
            <pre><code>switch значение {
case 1:
    // код для случая 1
case 2:
    // код для случая 2
default:
    // код по умолчанию
}</code></pre>
            <p>
                В отличие от <code>if-else</code>, <code>switch</code> позволяет проверять одно выражение на множество значений.
            </p>

            <b>3. Как работает цикл for?</b>
            <p>
                Цикл <code>for</code> в Go используется для повторения блока кода. Он может быть использован в нескольких формах: с инициализацией, условием и итерацией; только с условием; или как бесконечный цикл. Пример:
            </p>
            <pre><code>for i := 0; i < 10; i++ {
    fmt.Println(i)
}</code></pre>
            <p>
                Также можно использовать <code>for условие</code> или <code>for { // бесконечный цикл }</code>.
            </p>

            <b>4. Как работают операторы break и continue?</b>
            <p>
                Оператор <code>break</code> используется для выхода из цикла, а оператор <code>continue</code> пропускает оставшуюся часть текущей итерации и переходит к следующей. Примеры:
            </p>
            <pre><code>for i := 0; i < 10; i++ {
    if i == 5 {
        break // выйдет из цикла, когда i равно 5
    }
    fmt.Println(i)
}</code></pre>
            <pre><code>for i := 0; i < 10; i++ {
    if i%2 == 0 {
        continue // пропустит четные числа
    }
    fmt.Println(i) // выведет только нечетные числа
}</code></pre>

            <b>5. Как работает оператор goto (хотя его использование не рекомендуется)?</b>
            <p>
                Оператор <code>goto</code> позволяет передать управление к метке, определенной в коде. Хотя его использование возможно, оно не рекомендуется, так как может усложнить понимание кода и привести к ошибкам. Пример использования:
            </p>
            <pre><code>label:
fmt.Println("Hello")
goto label // бесконечный цикл, возвращает управление к метке
}</code></pre>
            <p>
                Лучше избегать использования <code>goto</code>, если это возможно, и предпочитать более структурированные подходы.
            </p>

            <h2>• Функции:</h2>
            <b>1. Как объявить функцию?</b>
            <p>
                Функцию в Go можно объявить с помощью ключевого слова <code>func</code>, за которым следует имя функции, список параметров в круглых скобках и тело функции. Например:
            </p>
            <pre><code>func MyFunction(param1 int, param2 string) {
    // тело функции
}</code></pre>

            <b>2. Что такое параметры и аргументы функции?</b>
            <p>
                Параметры — это переменные, указанные в определении функции, которые принимают значения при вызове функции. Аргументы — это фактические значения, которые передаются в функцию при её вызове. Например:
            </p>
            <pre><code>func Add(a int, b int) int {
    return a + b
}
result := Add(5, 3) // 5 и 3 — это аргументы</code></pre>

            <b>3. Что такое возвращаемые значения функции? Можно ли возвращать несколько значений?</b>
            <p>
                Возвращаемые значения функции — это значения, которые функция возвращает после выполнения. В Go можно возвращать несколько значений, указав их типы через запятую в определении функции. Например:
            </p>
            <pre><code>func Divide(a int, b int) (int, int) {
    return a / b, a % b
}</code></pre>

            <b>4. Что такое именованные возвращаемые значения?</b>
            <p>
                Именованные возвращаемые значения — это параметры, которые объявлены в заголовке функции. Они позволяют возвращать значения без явного использования оператора <code>return</code>. Например:
            </p>
            <pre><code>func Swap(a, b int) (x int, y int) {
    x = b
    y = a
    return // возвращает x и y
}</code></pre>

            <b>5. Что такое variadic function (функция с переменным числом аргументов)?</b>
            <p>
                Variadic function — это функция, которая принимает переменное количество аргументов одного типа. В Go это достигается с помощью многоточия <code>...</code> перед типом параметра. Например:
            </p>
            <pre><code>func Sum(nums ...int) int {
    total := 0
    for _, num := range nums {
        total += num
    }
    return total
}
result := Sum(1, 2, 3, 4) // result будет равен 10</code></pre>

            <b>6. Как передаются аргументы в функцию: по значению или по ссылке?</b>
            <p>
                В Go аргументы передаются по значению, что означает, что функция получает копию переданных значений. Однако если аргументом является указатель или ссылка на структуру, то изменения внутри функции будут отражены на оригинальном значении.
            </p>


            <h2>• Указатели:</h2>
            <b>1. Что такое указатель?</b>
            <p>
                Указатель — это переменная, которая хранит адрес другой переменной в памяти. В Go указатели позволяют ссылаться на значения, не копируя их, что может быть полезно для работы с большими структурами данных или для управления памятью.
            </p>

            <b>2. Зачем нужен указатель?</b>
            <p>
                Указатели необходимы для:
            <ul>
                <li>Избежания копирования больших структур данных при передаче их в функции.</li>
                <li>Изменения значений переменных, переданных в функции, поскольку передача происходит по ссылке.</li>
                <li>Управления памятью более эффективно, особенно в случае динамического выделения памяти.</li>
            </ul>
            </p>

            <b>3. Как получить адрес переменной?</b>
            <p>
                Для получения адреса переменной используется оператор <code>&</code>. Например:
            </p>
            <pre><code>x := 10
ptr := &x // ptr теперь содержит адрес переменной x</code></pre>

            <b>4. Как разыменовать указатель?</b>
            <p>
                Для разыменования указателя используется оператор <code>*</code>. Это позволяет получить значение, на которое указывает указатель. Например:
            </p>
            <pre><code>x := 10
ptr := &x
value := *ptr // value теперь равно 10</code></pre>

            <b>5. Зачем нужны указатели?</b>
            <p>
                Указатели нужны для:
            <ul>
                <li>Эффективного управления памятью и избежания ненужного копирования данных.</li>
                <li>Изменения значений переменных из функции, что позволяет возвращать измененные данные без необходимости использовать возвращаемое значение.</li>
                <li>Работы с динамическими структурами данных, такими как списки и деревья.</li>
            </ul>
            </p>


            <h2>• Структуры (Structs):</h2>
            <b>1. Что такое структура? Как она объявляется?</b>
            <p>
                Структура в Go — это составной тип данных, который позволяет объединять различные типы данных в одном объекте. Она используется для создания сложных объектов, которые могут содержать несколько полей. Объявление структуры происходит с помощью ключевого слова <code>type</code>, за которым следует имя структуры и ключевое слово <code>struct</code>.
            </p>
            <pre><code>type Person struct {
    Name string
    Age  int
}</code></pre>

            <b>2. Как получить доступ к полям структуры?</b>
            <p>
                Доступ к полям структуры осуществляется через точечную нотацию. Для этого нужно создать экземпляр структуры и использовать его имя, за которым следует точка и имя поля.
            </p>
            <pre><code>person := Person{Name: "Alice", Age: 30}
fmt.Println(person.Name) // Выводит: Alice
fmt.Println(person.Age)  // Выводит: 30</code></pre>

            <b>3. Что такое анонимные поля структуры (embedded fields)?</b>
            <p>
                Анонимные поля, или встроенные поля, — это поля структуры, которые не имеют имени. Они позволяют встраивать другие структуры в текущую структуру, что дает возможность использовать их поля напрямую без указания имени поля. Это упрощает доступ к полям встроенной структуры.
            </p>
            <pre><code>type Address struct {
    City    string
    Country string
}

type Person struct {
    Name    string
    Age     int
    Address // Анонимное поле
}</code></pre>
            <p>
                В этом примере можно получить доступ к полям <code>City</code> и <code>Country</code> напрямую через экземпляр <code>Person</code>:
            </p>
            <pre><code>person := Person{Name: "Alice", Age: 30, Address: Address{City: "New York", Country: "USA"}}
fmt.Println(person.City)    // Выводит: New York
fmt.Println(person.Country)  // Выводит: USA</code></pre>


            <h2>• Срезы (Slices):</h2>
            <b>1. Что такое срез в Go?</b>
            <p>
                Срез — это динамический массив, который может изменять свой размер во время выполнения программы. Он является более гибкой альтернативой массивам, которые имеют фиксированную длину. Основное отличие между срезами и массивами заключается в том, что срезы могут изменять свою длину, а массивы — нет.
            </p>

            <b>2. Как создать срез?</b>
            <p>
                Срезы можно создавать несколькими способами:
            </p>
            <ul>
                <li>С использованием <code>make</code>:</li>
                <pre><code>mySlice := make([]int, 0)</code></pre>
                <li>С использованием литералов срезов:</li>
                <pre><code>mySlice := []int{1, 2, 3}</code></pre>
            </ul>

            <b>3. Что такое capacity и length среза?</b>
            <p>
                <code>length</code> (длина) среза — это количество элементов, которые он содержит, а <code>capacity</code> (вместимость) — это максимальное количество элементов, которые срез может содержать без перераспределения памяти. Вместимость может быть больше или равна длине.
            </p>

            <b>4. Как добавить элементы в срез?</b>
            <p>
                Для добавления элементов в срез используется функция <code>append</code>:
            </p>
            <pre><code>mySlice = append(mySlice, 4)</code></pre>

            <b>5. Что происходит, когда capacity среза превышается при использовании append?</b>
            <p>
                Когда количество элементов в срезе превышает его вместимость, Go автоматически выделяет новую память для большего среза, копирует существующие элементы в новую область памяти и добавляет новый элемент. Это может быть дорогостоящей операцией, поэтому рекомендуется заранее планировать размер среза, если это возможно.
            </p>

            <b>6. Как скопировать срез?</b>
            <p>
                Для копирования одного среза в другой используется функция <code>copy</code>:
            </p>
            <pre><code>copy(destinationSlice, sourceSlice)</code></pre>
            <p>
                Здесь <code>destinationSlice</code> должен иметь достаточную длину для хранения всех элементов из <code>sourceSlice</code>.
            </p>

            <h2>• Карты (Maps):</h2>
            <b>0. Что такое map в golang?</b>
            <p>
                <code>map</code> в Go — это встроенный тип данных, который представляет собой неупорядоченную коллекцию пар "ключ-значение". Каждый ключ уникален, и он используется для быстрого доступа к соответствующему значению.
            </p>

            <b>1. Как создать карту?</b>
            <p>
                Карты можно создавать несколькими способами:
            </p>
            <ul>
                <li>С использованием <code>make</code>:</li>
                <pre><code>myMap := make(map[string]int)</code></pre>
                <li>С использованием литералов карты:</li>
                <pre><code>myMap := map[string]int{"one": 1, "two": 2}</code></pre>
            </ul>

            <b>2. Как получить значение из карты?</b>
            <p>
                Чтобы получить значение по ключу, используйте следующий синтаксис:
            </p>
            <pre><code>value := myMap["one"]</code></pre>

            <b>3. Как проверить, существует ли ключ в карте? (comma ok idiom)</b>
            <p>
                Для проверки существования ключа в карте можно использовать следующую конструкцию:
            </p>
            <pre><code>value, ok := myMap["one"]</code></pre>
            <p>
                Здесь <code>ok</code> будет <code>true</code>, если ключ существует, и <code>false</code>, если его нет.
            </p>

            <b>4. Как удалить элемент из карты? (delete)</b>
            <p>
                Чтобы удалить элемент из карты, используйте функцию <code>delete</code>:
            </p>
            <pre><code>delete(myMap, "one")</code></pre>

            <b>5.Что такое хеш коллизия в golang и как её разрешить?</b>
            <p>
                Хеш коллизия возникает, когда два разных ключа хешируются в один и тот же индекс в хеш-таблице. В Go карты используют внутреннюю структуру данных для разрешения коллизий, которая позволяет хранить несколько значений по одному индексу. Это достигается за счет использования связных списков или других структур данных для хранения значений, которые имеют одинаковый хеш.
            </p>


            <h2>• Строки:</h2>
            <b>1. Что такое строка в Go?</b>
            <p>
                В Go строка — это последовательность байтов, представляющая текст. Строки являются неизменяемыми (immutable) и могут содержать любые данные, включая символы, пробелы и специальные знаки. Строки в Go имеют тип <code>string</code> и могут быть созданы с помощью литералов или конкатенации.
            </p>

            <b>2. Что значит неизменяемость строк?</b>
            <p>
                Неизменяемость строк означает, что после создания строки ее содержимое не может быть изменено. Любые операции, которые кажутся изменяющими строку, на самом деле создают новую строку. Это свойство позволяет улучшить производительность и безопасность, так как предотвращает случайные изменения данных.
            </p>

            <b>3. Что за UTF-8 кодировка?</b>
            <p>
                UTF-8 — это стандарт кодирования символов, который позволяет представлять все символы Юникода. Он использует переменную длину байтов для кодирования символов, что делает его эффективным для текстов на английском языке и поддерживает множество других языков. В Go строки по умолчанию используют кодировку UTF-8.
            </p>

            <b>4. Как получить длину строки в байтах и в рунах? (len, utf8.RuneCountInString)?</b>
            <p>
                Длину строки в байтах можно получить с помощью функции <code>len()</code>, которая возвращает количество байтов в строке. Для получения длины строки в рунах (количества символов) используется функция <code>utf8.RuneCountInString()</code>, которая учитывает многобайтовые символы.
            </p>

            <b>5. Как итерировать по строке?</b>
            <p>
                Для итерации по строке в Go можно использовать цикл <code>for</code> с <code>range</code>, который позволяет перебрать символы строки по их рунам. Пример:
            <pre>
    for i, r := range str {
        fmt.Printf("Индекс: %d, Руна: %c\n", i, r)
    }
    </pre>
            </p>

            <b>6. Как преобразовать строку в []byte и []rune и наоборот?</b>
            <p>
                Чтобы преобразовать строку в <code>[]byte</code>, можно использовать явное приведение:
            <pre>
    byteSlice := []byte(str)
    </pre>
            Для преобразования строки в <code>[]rune</code> используется функция <code>[]rune(str)</code>:
            <pre>
    runeSlice := []rune(str)
    </pre>
            Чтобы преобразовать <code>[]byte</code> обратно в строку, можно использовать:
            <pre>
    strFromBytes := string(byteSlice)
    </pre>
            А для преобразования <code>[]rune</code> обратно в строку:
            <pre>
    strFromRunes := string(runeSlice)
    </pre>
            </p>


            <h2>• Пакеты:</h2>
            <b>1. Что такое пакет?</b>
            <p>
                Пакет в Go — это группа связанных файлов, которые могут содержать функции, переменные, типы и другие пакеты. Пакеты позволяют организовать код, делая его более структурированным и модульным. Каждый пакет имеет уникальное имя и может быть использован в других пакетах через импорт.
            </p>

            <b>2. Как импортировать пакет?</b>
            <p>
                Для импорта пакета в Go используется ключевое слово <code>import</code>. Импортируемый пакет указывается в круглых скобках или через запятую. Например:
            <pre>
    import (
        "fmt"
        "math"
    )
    </pre>
            Также можно импортировать пакет с псевдонимом:
            <pre>
    import m "math"
    </pre>
            После этого можно использовать функции из пакета, например: <code>m.Sqrt(16)</code>.
            </p>

            <b>3. Что такое видимость (scope) переменных и функций в пакете (публичные/приватные)?</b>
            <p>
                В Go видимость переменных и функций определяется по первой букве имени. Если имя начинается с заглавной буквы, элемент является публичным (exported) и доступен из других пакетов. Если имя начинается с маленькой буквы, элемент является приватным (unexported) и доступен только внутри своего пакета. Это позволяет контролировать доступ к элементам и инкапсулировать реализацию.
            </p>


            <h1>2. Конкурентность (Concurrency)</h1>

            <h2>• Горутины (Goroutines):</h2>
            <b>1. Что такое горутина? Чем она отличается от потока?</b>
            <p>
                Горутина — это легковесный поток выполнения в языке Go. Она позволяет запускать функции асинхронно, не блокируя основной поток выполнения программы. Основное отличие горутин от потоков заключается в том, что горутины управляются планировщиком Go, который более эффективно распределяет ресурсы, чем операционная система. Горутины занимают меньше памяти и могут быть созданы в большем количестве, чем традиционные потоки.
            </p>

            <b>2. Как запустить горутину? (go keyword)</b>
            <p>
                Чтобы запустить горутину, используется ключевое слово <code>go</code> перед вызовом функции. Например:
            <pre>
    go myFunction()
    </pre>
            Это запускает <code>myFunction</code> как горутину, позволяя основной программе продолжать выполнение, не дожидаясь завершения этой функции.
            </p>

            <b>3. Как работает планировщик горутин? (M:N scheduling)</b>
            <p>
                Планировщик горутин в Go использует модель M:N, где M — это количество операционных системных потоков, а N — количество горутин. Планировщик распределяет горутины по доступным потокам, эффективно управляя их выполнением. Это позволяет многим горутинам работать одновременно на ограниченном количестве системных потоков, что обеспечивает высокую производительность и низкие накладные расходы.
            </p>

            <b>4. Что такое вытесняющая многозадачность (preemptive scheduling) в Go?</b>
            <p>
                Вытесняющая многозадачность в Go означает, что планировщик может приостанавливать выполнение горутин в любой момент для переключения на другую горутину. Это позволяет избежать блокировки выполнения программы, если одна из горутин застряла или выполняется слишком долго. В Go вытесняющая многозадачность реализована через таймеры и механизмы синхронизации, что обеспечивает более эффективное использование ресурсов.
            </p>


            <h2>Каналы (Channels)</h2>
            <b>1. Что такое канал?</b>
            <p>
                Канал в языке Go — это средство для синхронизации и обмена данными между горутинами. Он позволяет одной горутине отправлять данные, а другой — получать их, обеспечивая безопасный доступ к общим данным без необходимости использования мьютексов.
            </p>

            <b>2. Как создать канал? (make(chan Type))</b>
            <p>
                Чтобы создать канал, используется встроенная функция <code>make</code>. Синтаксис выглядит следующим образом:
            <pre>
    myChannel := make(chan Type)
    </pre>
            Здесь <code>Type</code> — это тип данных, которые будут передаваться через канал.
            </p>

            <b>3. Какие типы каналов есть? (buffered/unbuffered)</b>
            <p>
                В Go существуют два типа каналов:
            <ul>
                <li><b>Небуферизованные каналы</b> (unbuffered) — передача данных происходит только тогда, когда отправитель и получатель готовы.</li>
                <li><b>Буферизованные каналы</b> (buffered) — могут хранить несколько значений до тех пор, пока они не будут прочитаны, что позволяет отправителю продолжать работу, не дожидаясь получения данных.</li>
            </ul>
            </p>

            <b>4. Как отправить и получить данные из канала? (<- operator)</b>
            <p>
                Для отправки данных в канал используется оператор <code>&lt;-</code>. Пример отправки:
            <pre>
    myChannel &lt;- value
    </pre>
            Для получения данных из канала также используется оператор <code>&lt;-</code>:
            <pre>
    value := &lt;-myChannel
    </pre>
            </p>

            <b>5. Что происходит, когда отправляется данные в полный буферизованный канал или принимается данные из пустого небуферизованного канала? (блокировка)</b>
            <p>
                Если попытаться отправить данные в полный буферизованный канал, операция блокируется до тех пор, пока не освободится место в канале. Аналогично, если попытаться получить данные из пустого небуферизованного канала, операция также блокируется до тех пор, пока данные не станут доступны.
            </p>

            <b>6. Как закрыть канал? (close)</b>
            <p>
                Канал закрывается с помощью функции <code>close</code>. Это сигнализирует другим горутинам о том, что больше данных не будет отправлено:
            <pre>
    close(myChannel)
    </pre>
            </p>

            <b>7. Как проверить, закрыт ли канал? (comma ok idiom)</b>
            <p>
                Чтобы проверить, закрыт ли канал, можно использовать так называемую "comma ok idiom". При получении данных из канала можно проверить второй возвращаемый параметр:
            <pre>
    value, ok := &lt;-myChannel
    </pre>
            Если <code>ok</code> равно <code>false</code>, это означает, что канал закрыт.
            </p>

            <b>8. Что такое select statement? Как он используется для выбора из нескольких каналов?</b>
            <p>
                <code>select</code> — это конструкция в Go, которая позволяет ожидать выполнения операций на нескольких каналах одновременно. Она выбирает первый доступный канал для чтения или записи и выполняет соответствующий блок кода. Это особенно полезно для обработки многопоточности и асинхронного взаимодействия между горутинами.
            </p>


            <h2>Мьютексы (Mutexes)</h2>
            <b>1. Что такое мьютекс? Зачем он нужен?</b>
            <p>
                Мьютекс (mutex) — это механизм синхронизации, который используется для обеспечения взаимного исключения при доступе к общим ресурсам в многопоточных приложениях. Он предотвращает одновременный доступ нескольких горутин к критическим секциям кода, тем самым защищая данные от гонок и обеспечивая их целостность.
            </p>

            <b>2. Как использовать мьютекс для защиты общих ресурсов? (Lock, Unlock)</b>
            <p>
                Для использования мьютекса в Go необходимо создать экземпляр типа <code>sync.Mutex</code>. Чтобы защитить общий ресурс, необходимо вызвать метод <code>Lock()</code> перед доступом к ресурсу и <code>Unlock()</code> после завершения работы с ним. Пример:
            <pre>
    var mu sync.Mutex
    mu.Lock()
    // Доступ к общему ресурсу
    mu.Unlock()
    </pre>
            </p>

            <b>3. Что такое RWMutex (мьютекс для чтения/записи)? Когда его следует использовать?</b>
            <p>
                <code>RWMutex</code> — это расширенная версия мьютекса, которая позволяет иметь несколько читателей или одного писателя одновременно. Он предоставляет два метода: <code>RLock()</code> и <code>RUnlock()</code> для блокировки чтения и <code>Lock()</code> и <code>Unlock()</code> для блокировки записи. <code>RWMutex</code> следует использовать, когда нужно часто читать данные и реже их изменять, так как это позволяет повысить производительность за счет параллельного чтения.
            </p>


            <h2>WaitGroup</h2>
            <b>1. Что такое sync.WaitGroup? Зачем он нужен?</b>
            <p>
                <code>sync.WaitGroup</code> — это структура в Go, которая используется для ожидания завершения группы горутин. Она позволяет главной горутине ждать, пока все запущенные горутины завершат свою работу. Это особенно полезно в ситуациях, когда необходимо дождаться выполнения нескольких параллельных задач перед продолжением выполнения программы.
            </p>

            <b>2. Как использовать sync.WaitGroup для ожидания завершения нескольких горутин? (Add, Done, Wait)</b>
            <p>
                Чтобы использовать <code>sync.WaitGroup</code>, необходимо выполнить следующие шаги:
            <ol>
                <li>Создайте экземпляр <code>sync.WaitGroup</code>.</li>
                <li>Перед запуском каждой горутины вызовите метод <code>Add(1)</code>, чтобы увеличить счетчик.</li>
                <li>Внутри каждой горутины, после завершения ее работы, вызовите метод <code>Done()</code>, чтобы уменьшить счетчик.</li>
                <li>После запуска всех горутин вызовите метод <code>Wait()</code>, чтобы заблокировать выполнение до тех пор, пока счетчик не станет равным нулю.</li>
            </ol>
            Пример:
            <pre>
    var wg sync.WaitGroup

    for i := 0; i < 5; i++ {
        wg.Add(1)
        go func(i int) {
            defer wg.Done()
            // Работа горутины
        }(i)
    }

    wg.Wait() // Ожидание завершения всех горутин
    </pre>
            </p>

            <h2>Context</h2>
            <b>1. Что такое context.Context? Зачем он нужен?</b>
            <p>
                <code>context.Context</code> — это интерфейс в Go, который используется для передачи информации о контексте выполнения между горутинами. Он позволяет управлять временем выполнения операций, отменять их и передавать значения. <code>context.Context</code> полезен в ситуациях, когда необходимо контролировать продолжительность выполнения задачи или передавать данные (например, идентификаторы запросов) между горутинами.
            </p>

            <b>2. Как использовать context.Context для отмены горутин и передачи данных между ними? (WithCancel, WithTimeout, WithValue)</b>
            <p>
                <code>context.Context</code> можно использовать для отмены горутин и передачи данных следующим образом:
            <ol>
                <li><code>WithCancel</code>: создает новый контекст с функцией отмены. Когда вызывается эта функция, все горутины, использующие этот контекст, могут завершить свою работу.</li>
                <li><code>WithTimeout</code>: создает новый контекст с установленным таймаутом. Если время истекает, контекст автоматически отменяется.</li>
                <li><code>WithValue</code>: позволяет передавать данные через контекст. Это полезно для передачи значений (например, метаданных) между функциями и горутинами.</li>
            </ol>
            Пример использования:
            <pre>
    ctx, cancel := context.WithCancel(context.Background())
    defer cancel() // Отмена контекста при завершении работы

    go func() {
        // Проверка на отмену
        select {
        case <-ctx.Done():
            // Завершение работы
        }
    }()

    // Передача данных через контекст
    ctx = context.WithValue(ctx, "key", "value")
    value := ctx.Value("key").(string) // Получение значения
    </pre>
            </p>


            <h1>Race conditions</h1>
            <b>1. Что такое race condition? Как их избежать?</b>
            <p>
                <code>Race condition</code> — это состояние, которое возникает, когда два или более потоков (или горутин) одновременно пытаются изменить одно и то же состояние или ресурс, и результат выполнения зависит от порядка выполнения этих потоков. Это может привести к непредсказуемым результатам и ошибкам в программе.
            </p>
            <p>
                Чтобы избежать <code>race conditions</code>, можно использовать следующие подходы:
            <ul>
                <li><code>Mutex</code>: Используйте мьютексы для синхронизации доступа к разделяемым ресурсам. Это гарантирует, что только одна горутина может получить доступ к ресурсу в любой момент времени.</li>
                <li><code>Channels</code>: Используйте каналы для передачи данных между горутинами, что позволяет избежать прямого доступа к разделяемым переменным.</li>
                <li><code>Atomic Operations</code>: Используйте атомарные операции для выполнения операций над переменными, которые не требуют блокировок.</li>
            </ul>
            </p>

            <b>2. Какие инструменты Go помогают обнаружить race conditions? (go run -race)</b>
            <p>
                В Go существует встроенный инструмент для обнаружения <code>race conditions</code>, который можно использовать при запуске программы. Для этого необходимо добавить флаг <code>-race</code> при выполнении команды <code>go run</code> или <code>go test</code>. Например:
            <pre>
    go run -race your_program.go
    </pre>
            Этот инструмент анализирует выполнение программы и сообщает о любых потенциальных состояниях гонки, что позволяет разработчикам выявлять и устранять проблемы в коде.
            </p>


            <h1>Интерфейсы (Interfaces) и типы</h1>

            <h2>Интерфейсы</h2>
            <b>1. Что такое интерфейс?</b>
            <p>
                Интерфейс в Go — это тип, который определяет набор методов, которые должны быть реализованы другими типами. Интерфейсы позволяют создавать обобщенные функции и структуры, работающие с различными типами данных, которые реализуют заданные методы.
            </p>

            <b>2. Как объявить интерфейс?</b>
            <p>
                Интерфейс объявляется с помощью ключевого слова <code>type</code>, за которым следует имя интерфейса и ключевое слово <code>interface</code>. Например:
            <pre>
    type MyInterface interface {
        MyMethod()
    }
    </pre>
            </p>

            <b>3. Что такое interface satisfaction (удовлетворение интерфейса)?</b>
            <p>
                Удовлетворение интерфейса происходит, когда тип реализует все методы, определенные в интерфейсе. В Go не требуется явно указывать, что тип реализует интерфейс; достаточно, чтобы он имел необходимые методы.
            </p>

            <b>4. Что такое пустой интерфейс (interface{})? Для чего он используется?</b>
            <p>
                Пустой интерфейс <code>interface{}</code> — это интерфейс без методов, который может представлять любой тип данных. Он используется для создания функций и структур, которые могут работать с любыми значениями, что делает его полезным для написания обобщенного кода.
            </p>

            <b>5. Type assertion (утверждение типа): Как проверить и преобразовать тип интерфейса?</b>
            <p>
                Утверждение типа позволяет проверить, является ли значение интерфейса конкретным типом, и при необходимости преобразовать его к этому типу. Синтаксис выглядит так:
            <pre>
    value, ok := myInterface.(MyType)
    </pre>
            Здесь <code>value</code> — это значение преобразованного типа, а <code>ok</code> — булевый флаг, указывающий, успешно ли прошло преобразование.
            </p>

            <b>6. Type switch (переключатель типа): Как обрабатывать различные типы интерфейсов в одном блоке кода?</b>
            <p>
                Переключатель типа позволяет выполнять разные действия в зависимости от типа значения, хранящегося в интерфейсе. Синтаксис выглядит так:
            <pre>
    switch v := myInterface.(type) {
    case MyType1:
        // обработка MyType1
    case MyType2:
        // обработка MyType2
    default:
        // обработка других типов
    }
    </pre>
            </p>


            <h2>Методы</h2>
            <b>1. Что такое метод?</b>
            <p>
                Метод в Go — это функция, связанная с определенным типом. Методы могут быть объявлены для пользовательских типов и позволяют вызывать функции, которые работают с данными этого типа. Методы имеют доступ к полям типа и могут изменять их состояние.
            </p>

            <b>2. Как объявить метод?</b>
            <p>
                Метод объявляется аналогично функции, но перед именем функции указывается тип, к которому он относится. Синтаксис выглядит так:
            <pre>
    func (t Type) MethodName() {
        // тело метода
    }
    </pre>
            Здесь <code>t</code> — это получатель (receiver), который представляет экземпляр типа <code>Type</code>.
            </p>

            <b>3. В чем разница между методом, принимающим value receiver и pointer receiver? Когда какой использовать?</b>
            <p>
                Разница между value receiver и pointer receiver заключается в том, как метод получает доступ к данным типа:
            <ul>
                <li><b>Value receiver:</b> Метод получает копию значения типа. Изменения, внесенные в методе, не влияют на оригинальный объект. Используйте value receiver, если метод не изменяет состояние объекта и если размер объекта небольшой.</li>
                <li><b>Pointer receiver:</b> Метод получает указатель на оригинальный объект. Изменения, внесенные в методе, будут отражены в оригинальном объекте. Используйте pointer receiver, если метод изменяет состояние объекта или если объект большой и вы хотите избежать накладных расходов на копирование.</li>
            </ul>
            </p>

            <h2>Embedding</h2>
            <b>1. Что такое embedding (встраивание) в Go?</b>
            <p>
                Встраивание (embedding) в Go — это механизм, позволяющий включать одну структуру или интерфейс в другую. Это создает композицию, где встраиваемая структура становится частью внешней структуры. Встраивание позволяет использовать методы и поля встраиваемой структуры как если бы они были частью внешней структуры, что способствует повторному использованию кода и упрощает его организацию.
            </p>

            <b>2. Как встраивать структуры и интерфейсы?</b>
            <p>
                Для встраивания структуры достаточно указать ее тип внутри другой структуры без явного имени поля. Например:
            <pre>
    type Address struct {
        City  string
        State string
    }

    type Person struct {
        Name    string
        Age     int
        Address // Встраивание структуры Address
    }
    </pre>
            Аналогично можно встраивать интерфейсы, просто указывая их тип:
            <pre>
    type Reader interface {
        Read() error
    }

    type MyReader struct {
        Reader // Встраивание интерфейса Reader
    }
    </pre>
            </p>

            <b>3. Как работает promotion (продвижение) методов при встраивании?</b>
            <p>
                При встраивании методов встраиваемой структуры автоматически становятся доступными методам внешней структуры. Это называется продвижением (promotion). Например, если структура <code>Address</code> имеет метод <code>GetCity()</code>, то его можно вызывать через экземпляр <code>Person</code>:
            <pre>
    person := Person{Name: "Alice", Age: 30, Address: Address{City: "New York", State: "NY"}}
    city := person.GetCity() // Доступ к методу GetCity() через Person
    </pre>
            Это упрощает использование методов и делает код более читаемым.
            </p>


            <h1>Ошибки (Errors)</h1>

            <b>1. Как обрабатывать ошибки в Go?</b>
            <p>
                В Go ошибки обрабатываются с помощью возвращения значения типа <code>error</code> как второго значения из функции. Если функция завершилась успешно, первое значение будет содержать результат, а второе — <code>nil</code>. Если произошла ошибка, первое значение будет <code>nil</code>, а второе будет содержать информацию об ошибке. Например:
            <pre>
    func doSomething() (result int, err error) {
        // Логика функции
        if ошибка {
            return 0, errors.New("что-то пошло не так")
        }
        return результат, nil
    }
    </pre>
            </p>

            <b>2. Что такое интерфейс error?</b>
            <p>
                Интерфейс <code>error</code> в Go — это встроенный интерфейс, который определяет один метод:
            <pre>
    type error interface {
        Error() string
    }
    </pre>
            Все типы, которые реализуют этот метод, могут использоваться как ошибки. Это позволяет создавать пользовательские типы ошибок и обрабатывать их в коде.
            </p>

            <b>3. Как создать свой тип ошибки?</b>
            <p>
                Для создания собственного типа ошибки можно определить структуру и реализовать для нее метод <code>Error()</code>. Например:
            <pre>
    type MyError struct {
        Message string
    }

    func (e *MyError) Error() string {
        return e.Message
    }
    </pre>
            Затем можно создавать экземпляры этого типа и возвращать их как ошибки.
            </p>

            <b>4. Как возвращать и обрабатывать несколько ошибок?</b>
            <p>
                В Go можно возвращать несколько значений, включая несколько ошибок. Например:
            <pre>
    func doSomething() (result1 int, result2 int, err1 error, err2 error) {
        // Логика функции
        return 0, 0, nil, errors.New("вторая ошибка")
    }
    </pre>
            При обработке нужно проверять каждую ошибку отдельно:
            <pre>
    res1, res2, err1, err2 := doSomething()
    if err1 != nil {
        // Обработка первой ошибки
    }
    if err2 != nil {
        // Обработка второй ошибки
    }
    </pre>
            </p>

            <b>5. Что такое panic и recover? Когда их следует использовать?</b>
            <p>
                <code>panic</code> — это механизм для обработки невосстановимых ошибок в Go. Когда вызывается <code>panic</code>, программа немедленно прекращает выполнение текущей функции и начинает «подниматься» по стеку вызовов до тех пор, пока не будет найден <code>recover</code> или программа не завершится.

                <code>recover</code> — это функция, которая позволяет перехватить панику и восстановить выполнение программы. Использовать <code>panic</code> следует только для серьезных ошибок, которые нельзя обработать обычным способом, тогда как <code>recover</code> используется для предотвращения аварийного завершения программы.
            </p>

            <b>6. Что такое deferred functions (defer)? Как они используются для обработки ошибок и освобождения ресурсов?</b>
            <p>
                Функции с ключевым словом <code>defer</code> откладываются до завершения функции, в которой они были объявлены. Это удобно для освобождения ресурсов, таких как закрытие файлов или соединений. Например:
            <pre>
    func readFile(filename string) error {
        file, err := os.Open(filename)
        if err != nil {
            return err
        }
        defer file.Close() // Закрытие файла при выходе из функции

        // Логика чтения файла
        return nil
    }
    </pre>
            Также можно использовать <code>defer</code> для обработки ошибок перед выходом из функции.
            </p>


            <h1>Работа с памятью и производительность (Memory Management and Performance)</h1>

            <h2>Сборка мусора (Garbage Collection)</h2>
            <b>1. Как работает сборщик мусора в Go? (Concurrent mark and sweep)</b>
            <p>
                Сборщик мусора в Go использует алгоритм "Concurrent Mark and Sweep". Он работает в несколько этапов:
            <ul>
                <li><strong>Маркировка (Mark):</strong> Сборщик начинает с корневых объектов (глобальные переменные, стековые переменные) и помечает все доступные объекты. Этот процесс выполняется параллельно с выполнением программы.</li>
                <li><strong>Сборка (Sweep):</strong> После маркировки сборщик проходит по памяти и освобождает объекты, которые не были помечены, то есть те, которые больше не доступны.</li>
            </ul>
            Параллельная работа сборщика позволяет минимизировать время простоя приложения, что делает его эффективным для многопоточных программ.
            </p>

            <b>2. Что такое profiling и tracing? Как использовать pprof для анализа производительности?</b>
            <p>
                <strong>Profiling</strong> — это процесс анализа производительности программы, который помогает выявить узкие места, например, функции, которые занимают много времени или потребляют много памяти. <strong>Tracing</strong> — это метод отслеживания выполнения программы, который позволяет увидеть последовательность вызовов функций и их длительность.

                Для использования <code>pprof</code> в Go необходимо:
            <ol>
                <li>Импортировать пакет <code>net/http/pprof</code>.</li>
                <li>Запустить HTTP-сервер, который будет обслуживать профилирование.</li>
                <li>Собрать данные профилирования, используя специальные URL-адреса (например, <code>/debug/pprof/profile</code> для CPU профиля).</li>
                <li>Анализировать собранные данные с помощью командной строки <code>go tool pprof</code>.</li>
            </ol>
            Это позволяет разработчикам оптимизировать код и улучшать производительность приложений.
            </p>

            <b>3. Как избежать утечек памяти?</b>
            <p>
                Чтобы избежать утечек памяти в Go, следует учитывать несколько рекомендаций:
            <ul>
                <li><strong>Используйте встроенные инструменты:</strong> Регулярно проверяйте утечки памяти с помощью профилирования и анализа с помощью <code>pprof</code>.</li>
                <li><strong>Избегайте ненужных ссылок:</strong> Не оставляйте ссылки на объекты, которые больше не нужны. Например, избегайте замыканий, которые удерживают ссылки на большие структуры данных.</li>
                <li><strong>Используйте временные объекты:</strong> Если возможно, используйте временные объекты и избегайте создания долгоживущих объектов.</li>
                <li><strong>Закрывайте ресурсы:</strong> Всегда закрывайте открытые файлы, соединения и другие ресурсы, чтобы предотвратить утечки.</li>
                <li><strong>Проверяйте циклы:</strong> Избегайте бесконечных циклов и убедитесь, что все горутины завершаются корректно.</li>
            </ul>
            Следуя этим рекомендациям, можно значительно снизить риск утечек памяти в приложениях на Go.
            </p>


            <h2>Производительность</h2>
            <b>1. Какие инструменты Go помогают анализировать производительность?</b>
            <p>
                В Go для анализа производительности используются несколько инструментов:
            <ul>
                <li><strong>go tool pprof:</strong> Этот инструмент позволяет собирать и анализировать профили производительности, включая CPU и память. Он предоставляет визуализации, которые помогают выявить узкие места в коде.</li>
                <li><strong>go tool trace:</strong> Этот инструмент позволяет отслеживать выполнение программы, включая все вызовы функций и задержки. Он предоставляет детализированную информацию о том, как выполняется код, что помогает в выявлении проблем с производительностью.</li>
            </ul>
            Оба инструмента являются мощными средствами для оптимизации приложений на Go.
            </p>

            <b>2. Как оптимизировать код на Go?</b>
            <p>
                Оптимизация кода на Go может включать следующие подходы:
            <ul>
                <li><strong>Использование эффективных алгоритмов:</strong> Выбор правильного алгоритма может значительно повлиять на производительность приложения. Оценка сложности алгоритмов (временной и пространственной) помогает выбрать наиболее подходящие.</li>
                <li><strong>Избежание ненужных аллокаций:</strong> Сокращение количества выделений памяти может улучшить производительность. Используйте повторное использование объектов и структуры данных, чтобы минимизировать аллокации.</li>
                <li><strong>Использование strings.Builder для конкатенации строк:</strong> Вместо обычной конкатенации строк, которая создает новые строки на каждом шаге, используйте <code>strings.Builder</code>. Это позволяет избежать лишних аллокаций и повысить производительность при работе со строками.</li>
            </ul>
            </p>

            <b>3. Что такое escape analysis? Как она влияет на производительность?</b>
            <p>
                <strong>Escape analysis</strong> — это процесс, используемый компилятором Go для определения того, могут ли переменные "убежать" за пределы функции, в которой они были созданы. Если переменная не "убегает" (т.е. используется только внутри функции), компилятор может выделить память для нее на стеке вместо кучи.

                Это имеет значительное влияние на производительность:
            <ul>
                <li><strong>Улучшение скорости:</strong> Выделение памяти на стеке быстрее, чем на куче, что может снизить время выполнения функций.</li>
                <li><strong>Снижение нагрузки на сборщик мусора:</strong> Меньшее количество объектов в куче уменьшает частоту работы сборщика мусора и снижает накладные расходы на управление памятью.</li>
            </ul>
            Таким образом, эффективное использование escape analysis может привести к более быстрому и эффективному коду.
            </p>


            <h2>Reflection</h2>

            <b>1. Что такое reflection?</b>
            <p>
                Reflection в Go — это механизм, который позволяет программе получать информацию о типах, значениях и структуре данных во время выполнения. С помощью reflection можно динамически взаимодействовать с объектами, что делает возможным выполнение операций, которые обычно требуют знания типов на этапе компиляции.
            </p>

            <b>2. Когда следует использовать reflection?</b>
            <p>
                Reflection следует использовать в следующих случаях:
            <ul>
                <li><strong>Метапрограммирование:</strong> Когда необходимо писать код, который может обрабатывать различные типы данных или структуры, не зная их заранее.</li>
                <li><strong>Сериализация/десериализация:</strong> При работе с форматами данных (например, JSON или XML), где необходимо динамически извлекать или присваивать значения полям структур.</li>
            </ul>
            Однако стоит помнить, что использование reflection может привести к снижению производительности и безопасности типов.
            </p>

            <b>3. Какие типы и функции предоставляет пакет reflect?</b>
            <p>
                Пакет <code>reflect</code> предоставляет несколько важных типов и функций:
            <ul>
                <li><strong>TypeOf:</strong> Возвращает тип объекта.</li>
                <li><strong>ValueOf:</strong> Возвращает значение объекта.</li>
                <li><strong>Kind:</strong> Определяет базовый тип (например, int, string, struct и т.д.).</li>
                <li><strong>Field:</strong> Позволяет получить доступ к полям структуры.</li>
                <li><strong>Method:</strong> Позволяет получить доступ к методам структуры.</li>
            </ul>
            </p>

            <b>4. Какие ограничения у reflection?</b>
            <p>
                У reflection есть несколько ограничений:
            <ul>
                <li><strong>Снижение производительности:</strong> Операции с использованием reflection могут быть медленнее, чем операции с известными типами из-за дополнительных накладных расходов на проверку типов и другие операции.</li>
                <li><strong>Потеря безопасности типов:</strong> Reflection может привести к ошибкам времени выполнения, так как компилятор не может проверить типы на этапе компиляции, что может привести к панике или неправильному поведению программы.</li>
            </ul>
            </p>


            <h1>Concurrency patterns</h1>

            <b>1. Что такое Worker pools?</b>
            <p>
                Worker pools — это шаблон проектирования, который позволяет управлять ограниченным количеством горутин (workers), которые обрабатывают задачи из общего канала. Вместо создания новой горутины для каждой задачи, задачи распределяются между фиксированным числом воркеров, что помогает контролировать использование ресурсов и повышает производительность. Это особенно полезно в сценариях, где количество задач велико, а создание большого числа горутин может привести к перегрузке системы.
            </p>

            <b>2. Что такое Fan-in, Fan-out?</b>
            <p>
                Fan-in и Fan-out — это паттерны работы с каналами в Go.
            <ul>
                <li><strong>Fan-out:</strong> Это процесс, при котором одна горутина отправляет данные в несколько горутин. Это позволяет параллельно обрабатывать данные, что увеличивает производительность обработки.</li>
                <li><strong>Fan-in:</strong> Это процесс, при котором несколько горутин отправляют данные в одну горутину. Это позволяет агрегировать результаты из нескольких источников и упрощает обработку данных.</li>
            </ul>
            </p>

            <b>3. Что такое Pipelines?</b>
            <p>
                Pipelines в Go — это способ организации обработки данных, где выход одной горутины становится входом для другой. Этот подход позволяет создавать последовательные этапы обработки данных, где каждый этап выполняет свою задачу и передает результат следующему этапу. Pipelines часто используются для обработки потоков данных, позволяя легко масштабировать и улучшать читаемость кода.
            </p>

            <b>4. Что такое Context-aware operations?</b>
            <p>
                Context-aware operations в Go — это механизмы, которые позволяют передавать контекст выполнения (например, тайм-ауты, отмену операций и метаданные) между горутинами. Пакет <code>context</code> предоставляет возможность создавать контексты, которые можно использовать для управления временем жизни операций и отмены долгих задач. Это особенно полезно в сетевых приложениях и приложениях с длительными вычислениями, где важно контролировать выполнение и освобождать ресурсы при необходимости.
            </p>


            <h1>Code organization and design principles</h1>
            <b>1. Что такое SOLID principles</b>
            <p>
                SOLID — это набор пяти принципов объектно-ориентированного проектирования, которые помогают разработчикам создавать более гибкие и поддерживаемые программные системы. Эти принципы включают:
            <ul>
                <li><strong>S</strong> - Single Responsibility Principle (Принцип единственной ответственности): Каждый класс должен иметь только одну причину для изменения.</li>
                <li><strong>O</strong> - Open/Closed Principle (Принцип открытости/закрытости): Программные сущности должны быть открыты для расширения, но закрыты для модификации.</li>
                <li><strong>L</strong> - Liskov Substitution Principle (Принцип подстановки Лисков): Объекты должны быть заменяемыми экземплярами их подтипов без изменения правильности программы.</li>
                <li><strong>I</strong> - Interface Segregation Principle (Принцип разделения интерфейсов): Клиенты не должны зависеть от интерфейсов, которые они не используют.</li>
                <li><strong>D</strong> - Dependency Inversion Principle (Принцип инверсии зависимостей): Зависимости должны быть от абстракций, а не от конкретных реализаций.</li>
            </ul>
            </p>

            <b>2. DRY (Don't Repeat Yourself)</b>
            <p>
                Принцип DRY гласит, что информация не должна дублироваться в коде. Это помогает избежать ошибок, упрощает поддержку и делает код более читаемым. Вместо повторения одного и того же кода, разработчики должны стремиться к его абстракции и переиспользованию через функции, методы или структуры.
            </p>

            <b>3. KISS (Keep It Simple, Stupid)</b>
            <p>
                Принцип KISS утверждает, что системы должны быть как можно проще. Сложные решения могут привести к ошибкам и усложнению поддержки. Разработчики должны стремиться создавать простые и понятные решения, которые легко тестировать и поддерживать.
            </p>

            <b>4. YAGNI (You Ain't Gonna Need It)</b>
            <p>
                Принцип YAGNI говорит о том, что не следует добавлять функциональность до тех пор, пока она не станет необходимой. Это помогает избежать избыточности и усложнения кода, а также сосредоточиться на текущих потребностях проекта.
            </p>

            <b>5. Clean Architecture</b>
            <p>
                Clean Architecture — это архитектурный подход, который фокусируется на разделении кода на слои с четкими границами. Основная идея заключается в том, чтобы отделить бизнес-логику от деталей реализации (например, пользовательского интерфейса или базы данных). Это делает систему более гибкой и удобной для тестирования и поддержки.
            </p>

            <b>6. Dependency Injection</b>
            <p>
                Dependency Injection (DI) — это паттерн проектирования, который позволяет передавать зависимости в классы или функции вместо того, чтобы создавать их внутри. Это способствует уменьшению связанности кода и упрощает тестирование, так как зависимости можно легко заменять на моки или стабы при написании тестов.
            </p>


            <h1>Паттерны проектирования</h1>

            <b>1. Что такое Singleton и пример реализации на golang</b>
            <p>
                Singleton — это паттерн проектирования, который гарантирует, что класс имеет только один экземпляр и предоставляет глобальную точку доступа к этому экземпляру. В Go можно реализовать Singleton с использованием пакета sync для обеспечения потокобезопасности.
            </p>
            <pre>
package main

import (
    "fmt"
    "sync"
)

type singleton struct {
    value int
}

var instance *singleton
var once sync.Once

func GetInstance() *singleton {
    once.Do(func() {
        instance = &singleton{}
    })
    return instance
}

func main() {
    s1 := GetInstance()
    s2 := GetInstance()
    s1.value = 42
    fmt.Println(s2.value) // Вывод: 42
}
</pre>

            <b>2. Что такое Factory и пример реализации на golang</b>
            <p>
                Factory — это паттерн проектирования, который используется для создания объектов, не указывая конкретный класс создаваемого объекта. В Go можно реализовать Factory с помощью интерфейсов.
            </p>
            <pre>
package main

import "fmt"

type Shape interface {
    Draw()
}

type Circle struct{}

func (c *Circle) Draw() {
    fmt.Println("Drawing a Circle")
}

type Square struct{}

func (s *Square) Draw() {
    fmt.Println("Drawing a Square")
}

func ShapeFactory(shapeType string) Shape {
    if shapeType == "circle" {
        return &Circle{}
    } else if shapeType == "square" {
        return &Square{}
    }
    return nil
}

func main() {
    shape1 := ShapeFactory("circle")
    shape1.Draw() // Вывод: Drawing a Circle

    shape2 := ShapeFactory("square")
    shape2.Draw() // Вывод: Drawing a Square
}
</pre>

            <b>3. Что такое Builder и пример реализации на golang</b>
            <p>
                Builder — это паттерн проектирования, который позволяет создавать сложные объекты пошагово. В Go можно использовать структуры и методы для реализации этого паттерна.
            </p>
            <pre>
package main

import "fmt"

type House struct {
    walls  string
    roof   string
    windows int
}

type HouseBuilder struct {
    house House
}

func (b *HouseBuilder) BuildWalls(walls string) *HouseBuilder {
    b.house.walls = walls
    return b
}

func (b *HouseBuilder) BuildRoof(roof string) *HouseBuilder {
    b.house.roof = roof
    return b
}

func (b *HouseBuilder) BuildWindows(windows int) *HouseBuilder {
    b.house.windows = windows
    return b
}

func (b *HouseBuilder) Build() House {
    return b.house
}

func main() {
    builder := &HouseBuilder{}
    house := builder.BuildWalls("brick").BuildRoof("tile").BuildWindows(10).Build()

    fmt.Printf("House built with %s walls, %s roof and %d windows\n", house.walls, house.roof, house.windows)
}
</pre>

            <b>4. Что такое Observer и пример реализации на golang</b>
            <p>
                Observer — это паттерн проектирования, который позволяет объектам подписываться на события другого объекта и получать уведомления об изменениях. В Go можно реализовать его с помощью интерфейсов и срезов.
            </p>
            <pre>
package main

import "fmt"

type Observer interface {
    Update(data string)
}

type Subject struct {
    observers []Observer
}

func (s *Subject) Attach(observer Observer) {
    s.observers = append(s.observers, observer)
}

func (s *Subject) Notify(data string) {
    for _, observer := range s.observers {
        observer.Update(data)
    }
}

type ConcreteObserver struct {
    id int
}

func (co *ConcreteObserver) Update(data string) {
    fmt.Printf("Observer %d received data: %s\n", co.id, data)
}

func main() {
    subject := &Subject{}

    observer1 := &ConcreteObserver{id: 1}
    observer2 := &ConcreteObserver{id: 2}

    subject.Attach(observer1)
    subject.Attach(observer2)

    subject.Notify("Hello Observers!") // Уведомление всем наблюдателям
}
</pre>

            <b>5. Что такое Strategy и пример реализации на golang</b>
            <p>
                Strategy — это паттерн проектирования, который позволяет выбирать алгоритмы на этапе выполнения. В Go можно использовать интерфейсы для реализации различных стратегий.
            </p>
            <pre>
package main

import "fmt"

type Strategy interface {
    Execute(a, b int) int
}

type Add struct{}

func (a *Add) Execute(x, y int) int {
    return x + y
}

type Subtract struct{}

func (s *Subtract) Execute(x, y int) int {
    return x - y
}

type Context struct {
    strategy Strategy
}

func (c *Context) SetStrategy(strategy Strategy) {
    c.strategy = strategy
}

func (c *Context) ExecuteStrategy(x, y int) int {
    return c.strategy.Execute(x, y)
}

func main() {
    context := &Context{}

    context.SetStrategy(&Add{})
    fmt.Println("Addition:", context.ExecuteStrategy(5, 3)) // Вывод: Addition: 8

    context.SetStrategy(&Subtract{})
    fmt.Println("Subtraction:", context.ExecuteStrategy(5, 3)) // Вывод: Subtraction: 2
}
</pre>

            <b>6. Что такое Decorator и пример реализации на golang</b>
            <p>
                Decorator — это паттерн проектирования, который позволяет добавлять новые функциональности к объектам динамически. В Go его можно реализовать с помощью составных типов.
            </p>
            <pre>
package main

import "fmt"

type Coffee interface {
    Cost() float64
}

type SimpleCoffee struct{}

func (c *SimpleCoffee) Cost() float64 {
    return 2.0 // Базовая цена кофе
}

type MilkDecorator struct {
    coffee Coffee
}

func (m *MilkDecorator) Cost() float64 {
    return m.coffee.Cost() + 0.5 // Добавляем стоимость молока
}

type SugarDecorator struct {
    coffee Coffee
}

func (s *SugarDecorator) Cost() float64 {
    return s.coffee.Cost() + 0.2 // Добавляем стоимость сахара
}

func main() {
    coffee := &SimpleCoffee{}

    fmt.Println("Cost of simple coffee:", coffee.Cost()) // Вывод: Cost of simple coffee: 2

    milkCoffee := &MilkDecorator{coffee: coffee}

    fmt.Println("Cost of coffee with milk:", milkCoffee.Cost()) // Вывод: Cost of coffee with milk: 2.5

    sugarMilkCoffee := &SugarDecorator{coffee: milkCoffee}

    fmt.Println("Cost of coffee with milk and sugar:", sugarMilkCoffee.Cost()) // Вывод: Cost of coffee with milk and sugar: 2.7
}
</pre>


            <h1>Разное:</h1>
            <h2>Дополнительные темы в Go</h2>

            <ul>
                <li>
                    <strong>Что такое defer? Как он работает?</strong>
                    <p>Defer — это ключевое слово в Go, которое используется для отложенного выполнения функции. Функции, помеченные defer, будут выполнены после завершения enclosing функции, даже если произошла ошибка или паника. Это часто используется для освобождения ресурсов, таких как закрытие файлов или мьютексов.</p>
                </li>

                <li>
                    <strong>Что такое iota?</strong>
                    <p>Iota — это специальная идентификаторная константа в Go, которая используется для создания последовательных значений. Она автоматически увеличивается на единицу при каждой новой строке констант в блоке const.</p>
                </li>

                <li>
                    <strong>Как создать кастомный пакет? Как организовать код в Go?</strong>
                    <p>Для создания кастомного пакета необходимо создать директорию с кодом и добавить файл с расширением .go. В начале файла нужно указать имя пакета с помощью ключевого слова <code>package</code>. Код можно организовать по функциональности, разделяя его на различные пакеты и подкаталоги.</p>
                </li>

                <li>
                    <strong>Как работать с файлами? (os package)</strong>
                    <p>Пакет <code>os</code> предоставляет функции для работы с файловой системой. Вы можете открывать, создавать, читать и записывать файлы с помощью функций, таких как <code>os.Open</code>, <code>os.Create</code>, <code>os.ReadFile</code>, и <code>os.WriteFile</code>.</p>
                </li>

                <li>
                    <strong>Как работать с сетью? (net package)</strong>
                    <p>Пакет <code>net</code> предоставляет интерфейсы для работы с сетевыми соединениями. Вы можете создавать TCP/UDP-серверы и клиентов, а также работать с HTTP-запросами и ответами с помощью пакета <code>net/http</code>.</p>
                </li>

                <li>
                    <strong>Как написать тесты в Go? (testing package)</strong>
                    <p>Для написания тестов в Go используется пакет <code>testing</code>. Тесты пишутся в файлах с именем, заканчивающимся на <code>_test.go</code>, и должны содержать функции, начинающиеся с <code>Test</code>. Можно использовать команды <code>go test</code> для запуска тестов.</p>
                </li>

                <li>
                    <strong>Что такое benchmarks? Как их писать и запускать?</strong>
                    <p>Бенчмарки — это тесты производительности, которые измеряют время выполнения функций. Они пишутся в тех же файлах, что и тесты, и используют функцию с именем, начинающимся на <code>Benchmark</code>. Запуск бенчмарков осуществляется с помощью команды <code>go test -bench=.</code>.</p>
                </li>

                <li>
                    <strong>Как работает go mod? Управление зависимостями.</strong>
                    <p><code>go mod</code> — это инструмент для управления зависимостями в Go. Он позволяет создавать модули, указывать версии зависимостей в файле <code>go.mod</code>, а также автоматически загружать и обновлять зависимости.</p>
                </li>

                <li>
                    <strong>Что такое build tags?</strong>
                    <p>Build tags — это специальные комментарии в начале файла, которые указывают компилятору, когда включать или исключать файл из сборки. Это полезно для условной компиляции кода для различных платформ или конфигураций.</p>
                </li>
            </ul>
        </div>
    </div>



    <!-- ExtraContentModal -->
    <div class="modal fade" id="ExtraContentModal" tabindex="-1" aria-labelledby="exampleModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h1 class="modal-title fs-5" id="exampleModalLabel">Добавить ссылку на доп. матераил</h1>
                </div>
                <div class="modal-body">
                    <form action="5899.html" method="POST">
                        <input type="hidden" name="csrfmiddlewaretoken" value="2cRbCuVoFX5cN5aiC53jmvl2ZE8f7aswnnKnpVkI4rhssQmixzFAD5wFcOPbD9hN">
                        <div class="mb-3">
                            <label for="id_content-title" class="col-form-label">Название: </label>
                            <input type="text" name="content-title" class="form-control" maxlength="255" required id="id_content-title">
                        </div>
                        <div class="mb-3">
                            <label for="id_content-url" class="col-form-label">Ссылка: </label>
                            <input type="url" name="content-url" class="form-control" required id="id_content-url">
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Закрыть</button>
                            <button type="submit" class="btn btn-primary">Добавить</button>
                        </div>
                    </form>
                </div>
            </div>
        </div>
    </div>

    <!-- VideoAnswerModal -->
    <div class="modal fade" id="VideoAnswerModal" tabindex="-1" aria-labelledby="VideoAnswerModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h1 class="modal-title fs-5" id="VideoAnswerModalLabel">Добавить ответ из mock-собесов</h1>
                </div>
                <div class="modal-body">
                    <form action="5899.html" method="POST">
                        <input type="hidden" name="csrfmiddlewaretoken" value="2cRbCuVoFX5cN5aiC53jmvl2ZE8f7aswnnKnpVkI4rhssQmixzFAD5wFcOPbD9hN">
                        <div class="mb-3">
                            <label for="id_video-title" class="col-form-label">Название видео: </label>
                            <input type="text" name="video-title" class="form-control" maxlength="255" required id="id_video-title">
                        </div>
                        <div class="mb-3">
                            <label for="id_video-url" class="col-form-label">Ссылка на момент ответа: </label>
                            <input type="url" name="video-url" class="form-control" required id="id_video-url">
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Закрыть</button>
                            <button type="submit" class="btn btn-primary">Добавить</button>
                        </div>
                    </form>
                </div>
            </div>
        </div>
    </div>



</main>
<script>hljs.highlightAll();</script>
</body>

<div class="container">
    <footer class="py-3 my-4">
        <p class="text-center nav-item nav-link px-2 text-body-secondary text-decoration-none text-reset fs-6">interviews</p>
        <ul class="nav justify-content-center pb-1 mb-1">
            <!--          <li class="nav-item nav-link px-2 text-body-secondary text-decoration-none text-reset fs-6">☀️interviews by Кивайко Алексей</li>-->
            <li class="nav-item"><a href="https://t.me/+3xsbmERSOP0wMWRi" target="_blank" class="nav-link px-2 text-body-secondary text-decoration-none text-reset fs-6"><i class="bi bi-telegram"></i></a></li>
            <li class="nav-item"><a href="https://www.youtube.com/@goingtoit" target="_blank" class="nav-link px-2 text-body-secondary text-decoration-none text-reset fs-6"><i class="bi bi-youtube"></i></a></li>
            <li class="nav-item"><a href="https://github.com/kivaiko" target="_blank" class="nav-link px-2 text-body-secondary text-decoration-none text-reset fs-6"><i class="bi bi-github"></i></a></li>
            <li class="nav-item"><a href="https://www.linkedin.com/in/kivaiko/" target="_blank" class="nav-link px-2 text-body-secondary text-decoration-none text-reset fs-6"><i class="bi bi-linkedin"></i></a></li>
            <li class="nav-item"><a href="https://www.instagram.com/kivaiyko/" target="_blank" class="nav-link px-2 text-body-secondary text-decoration-none text-reset fs-6"><i class="bi bi-instagram"></i></a></li>
            <li class="nav-item"><a href="https://twitter.com/kivaiyko" target="_blank" class="nav-link px-2 text-body-secondary text-decoration-none text-reset fs-6"><i class="bi bi-twitter"></i></a></li>
        </ul>
    </footer>
</div>
</html>
